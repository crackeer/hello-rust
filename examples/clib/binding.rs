/* automatically generated by rust-bindgen 0.66.1 */

pub const SS_OK: u32 = 0;
pub const SS_ERROR_INVALID_PARAM: u32 = 2;
pub const SS_ERROR_MEMORY_FAIELD: u32 = 3;
pub const SS_ERROR_INSUFFICIENT_BUFFER: u32 = 4;
pub const SS_ERROR_INVALID_HANDLE: u32 = 8;
pub const SS_ERROR_TIMEOUT: u32 = 9;
pub const SS_ERROR_UNSUPPORT: u32 = 16;
pub const SS_ERROR_NET_ERROR: u32 = 64;
pub const SS_ERROR_MASTER_UNSUPPORT_PIN: u32 = 68;
pub const SS_ERROR_MASTER_PIN_NOT_ACTIVE: u32 = 69;
pub const SS_ERROR_MASTER_OUTDATED_VERSION: u32 = 71;
pub const SS_ERROR_MASTER_PIN_WRONG: u32 = 72;
pub const SS_ERROR_MASTER_PIN_BLOCKED: u32 = 73;
pub const SS_ERROR_NET_TIMEOUT: u32 = 74;
pub const SS_ERROR_CONFIGURATION: u32 = 75;
pub const SS_ERROR_MASTER_NEED_UPDATE: u32 = 76;
pub const SS_ERROR_INIT_FAILED: u32 = 77;
pub const SS_ERROR_SERVER_NOT_FOUND: u32 = 83886084;
pub const SS_ERROR_NO_LOCK: u32 = 83886085;
pub const SS_ERROR_SLM_HANDLE_IS_FULL: u32 = 83886086;
pub const SS_ERROR_SYSTEM_ERROR: u32 = 83886093;
pub const SS_ERROR_WHITELISTED: u32 = 83886099;
pub const SS_ERROR_BLACKLISTED: u32 = 83886100;
pub const SS_ERROR_LOCK_NOT_FOUND: u32 = 83886111;
pub const SS_ERROR_D2C_NO_PACKAGE: u32 = 318767104;
pub const SS_ERROR_DEVELOPER_CERT_ALREADY_EXIST: u32 = 318767105;
pub const SS_ERROR_PARSE_CERT: u32 = 318767107;
pub const SS_ERROR_D2C_PACKAGE_TOO_LARGE: u32 = 318767108;
pub const SS_ERROR_RESPONSE: u32 = 318767109;
pub const SS_ERROR_RUNTIME_NOT_INITIALIZE: u32 = 318767111;
pub const SS_ERROR_RUNTIME_VERSION: u32 = 318767113;
pub const SS_ERROR_LIC_NOT_FOUND: u32 = 318767136;
pub const SS_ERROR_USER_DATA_TOO_SMALL: u32 = 318767140;
pub const SS_ERROR_INVALID_D2C_PACKAGE: u32 = 318767143;
pub const SS_ERROR_CLOUD_RESPONSE: u32 = 318767144;
pub const SS_ERROR_USER_DATA_TOO_LARGE: u32 = 318767145;
pub const SS_ERROR_INVALID_MEMORY_ID: u32 = 318767146;
pub const SS_ERROR_INVALID_MEMORY_OFFSET: u32 = 318767147;
pub const SS_ERROR_NO_LOGGED_USER: u32 = 318767152;
pub const SS_ERROR_USER_AUTH_SERVER_NOT_RUNNING: u32 = 318767153;
pub const SS_ERROR_LICENSE_MODULE_NOT_EXISTS: u32 = 318767159;
pub const SS_ERROR_DEVELOPER_PASSWORD: u32 = 318767160;
pub const SS_ERROR_CALLBACK_VERSION: u32 = 318767161;
pub const SS_ERROR_INFO_RELOGIN: u32 = 318767162;
pub const SS_ERROR_LICENSE_VERIFY: u32 = 318767163;
pub const SS_ERROR_LICENSE_NEED_TO_ACTIVATE: u32 = 318767185;
pub const SS_ERROR_IPC_FAILED: u32 = 33554434;
pub const SS_ERROR_IPC_CONNECT_FAILED: u32 = 33554435;
pub const ERROR_LM_SVC_INVALID_SESSION: u32 = 603979789;
pub const ERROR_LM_SVC_SESSION_ALREADY_DELETED: u32 = 603979790;
pub const ERROR_LM_SVC_LICENCE_EXPIRED: u32 = 603979791;
pub const ERROR_LM_SVC_SESSION_TIME_OUT: u32 = 603979792;
pub const ERROR_LM_REMOTE_LOGIN_DENIED: u32 = 603979797;
pub const SS_ERROR_FIRM_LICENCE_ALL_DISABLED: u32 = 570425358;
pub const SS_ERROR_FIRM_CUR_LICENCE_DISABLED: u32 = 570425359;
pub const SS_ERROR_FIRM_LICENCE_INVALID: u32 = 570425360;
pub const SS_ERROR_FIRM_LIC_STILL_UNAVALIABLE: u32 = 570425361;
pub const SS_ERROR_FIRM_LIC_TERMINATED: u32 = 570425362;
pub const SS_ERROR_FIRM_LIC_RUNTIME_TIME_OUT: u32 = 570425363;
pub const SS_ERROR_FIRM_LIC_COUNTER_IS_ZERO: u32 = 570425364;
pub const SS_ERROR_FIRM_LIC_MAX_CONNECTION: u32 = 570425365;
pub const SS_ERROR_FIRM_REACHED_MAX_SESSION: u32 = 570425367;
pub const SS_ERROR_FIRM_NOT_ENOUGH_SHAREMEMORY: u32 = 570425370;
pub const SS_ERROR_FIRM_INVALID_DATA_LEN: u32 = 570425372;
pub const SS_ERROR_FIRM_DATA_FILE_NOT_FOUND: u32 = 570425374;
pub const SS_ERROR_FIRM_INVALID_PKG_TYPE: u32 = 570425375;
pub const SS_ERROR_FIRM_INVALID_TIME_STAMP: u32 = 570425376;
pub const SS_ERROR_FIRM_INVALID_UPD_LIC_ID: u32 = 570425377;
pub const SS_ERROR_FIRM_LIC_ALREADY_EXIST: u32 = 570425378;
pub const SS_ERROR_FIRM_LICENCE_SIZE_LIMITTED: u32 = 570425379;
pub const SS_ERROR_FIRM_INVALID_DATA_FILE_OFFSET: u32 = 570425380;
pub const SS_ERROR_FIRM_SESSION_ALREADY_LOGOUT: u32 = 570425388;
pub const SS_ERROR_FIRM_INVALID_USER_DATA_TYPE: u32 = 570425393;
pub const SS_ERROR_FIRM_INVALID_DATA_FILE_SIZE: u32 = 570425394;
pub const SS_ERROR_FIRM_ALL_LIC_TERMINATED: u32 = 570425396;
pub const SS_ERROR_FIRM_UPDATE_FAILED: u32 = 570425400;
pub const SS_ERROR_FIRM_DATA_LENGTH_ALIGNMENT: u32 = 570425404;
pub const SS_ERROR_FIRM_DATA_CRYPTION: u32 = 570425405;
pub const SS_ERROR_FIRM_SHORTCODE_UPDATE_NOT_SUPPORTED: u32 = 570425406;
pub const SS_ERROR_FIRM_LIC_USR_DATA_NOT_EXIST: u32 = 570425408;
pub const SS_ERROR_FIRM_FILE_NOT_FOUND: u32 = 570425424;
pub const SS_ERROR_FIRM_INVLAID_DEVELOPER_ID: u32 = 570425433;
pub const SS_ERROR_FIRM_BEYOND_PKG_ITEM_SIZE: u32 = 570425437;
pub const SS_ERROR_FIRM_DEVICE_LOCKED: u32 = 570425439;
pub const SS_ERROR_FIRM_NOT_EXCHANGE_KEY: u32 = 570425441;
pub const SS_ERROR_FIRM_INVALID_SHORTCODE_SWAP_FILE: u32 = 570425442;
pub const SS_ERROR_FIRM_SHORTCODE_UPDATE_USER_DATA: u32 = 570425443;
pub const SS_ERROR_AUTH_SERVER_INVALID_TOKEN: u32 = 687865857;
pub const SS_ERROR_AUTH_SERVER_REFRESH_TOKEN: u32 = 687865858;
pub const SS_ERROR_AUTH_SERVER_LOGIN_CANCELED: u32 = 687865859;
pub const SS_ERROR_AUTH_SERVER_GET_ALL_USER_INFO_FAIL: u32 = 687865860;
pub const SS_ERROR_CLOUD_INVALID_TOKEN: u32 = 805306384;
pub const SS_ERROR_CLOUD_LICENSE_ALREADY_LOGIN: u32 = 805306385;
pub const SS_ERROR_CLOUD_LICENSE_EXPIRED: u32 = 805306386;
pub const SS_ERROR_CLOUD_SESSION_KICKED: u32 = 805306387;
pub const SS_ERROR_CLOUD_DEVELOPER_ACCOUNT: u32 = 805306388;
pub const SS_ERROR_CLOUD_LICENSE_LOGGED: u32 = 805306389;
pub const SS_ERROR_CLOUD_INVALID_SESSSION: u32 = 805310466;
pub const SS_ERROR_CLOUD_SESSION_TIMEOUT: u32 = 805310468;
pub const SS_ERROR_CLOUD_LICENSE_NOT_EXISTS: u32 = 822087681;
pub const SS_ERROR_CLOUD_LICENSE_NOT_ACTIVE: u32 = 822087682;
pub const SS_ERROR_CLOUD_LICENSE_EXPIRED2: u32 = 822087683;
pub const SS_ERROR_CLOUD_LICENSE_COUNTER_IS_ZERO: u32 = 822087684;
pub const SS_ERROR_CLOUD_LICENSE_RUNTIME_TIME_OUT: u32 = 822087685;
pub const SS_ERROR_CLOUD_LICENSE_MAX_CONNECTION: u32 = 822087686;
pub const SS_ERROR_CLOUD_LICENSE_LOCKED: u32 = 822087687;
pub const SS_ERROR_CLOUD_LICENSE_DATA_NOT_EXISTS: u32 = 822087688;
pub const SS_ERROR_CLOUD_LICENSE_STILL_UNAVAILABLE: u32 = 822087696;
pub const SS_ERROR_SO_BEFORE_START_TIME: u32 = 1358970884;
pub const SS_ERROR_SO_EXPIRED: u32 = 1358970885;
pub const SS_ERROR_SO_LICENSE_BIND_ERROR: u32 = 1358970886;
pub const SS_ERROR_SO_LICENSE_BIND_FULL: u32 = 1358970887;
pub const SS_ERROR_SO_LICENSE_UNBOUND: u32 = 1358970888;
pub const SS_ERROR_SO_LICENSE_MAX_BIND_FULL: u32 = 1358970889;
pub const SS_ERROR_SO_NOT_SUPPORTED_OFFLINE_BIND: u32 = 1358970896;
pub const SS_ERROR_SO_EXPIRED_C2D: u32 = 1358970897;
pub const SS_ERROR_SO_DEVELOPER_ACCOUNT: u32 = 1358970899;
pub const SS_ERROR_SO_OUTDATED_VERSION: u32 = 1358970900;
pub const SS_ERROR_LICKEY_QUERY_STATUS_REQ_ERROR: u32 = 1358974977;
pub const SS_ERROR_LICKEY_EXCHANGE_REQ_ERROR: u32 = 1358974978;
pub const SS_ERROR_LICKEY_NOT_EXIST: u32 = 1358974979;
pub const SS_ERROR_LICKEY_DEDUCT_FAILED: u32 = 1358974980;
pub const SS_ERROR_LICKEY_C2D_INVALID_CHAR_ENCODING: u32 = 1358974981;
pub const SS_ERROR_LICKEY_C2D_UNSUPPORTED_PROTO_TYPE: u32 = 1358974982;
pub const SS_ERROR_LICKEY_C2D_UNSUPPORTED_PROTO_VER: u32 = 1358974983;
pub const SS_ERROR_LICKEY_C2D_UNSUPPORTED_HWFP_VER: u32 = 1358974984;
pub const SS_ERROR_LICKEY_C2D_INCOMPATIBLE_MACHINE_ID: u32 = 1358974985;
pub const SS_ERROR_LICKEY_C2D_UNSUPPORTED_INFO_VER: u32 = 1358974986;
pub const SS_ERROR_LICKEY_C2D_OVERDUE: u32 = 1358974987;
pub const SS_ERROR_LICKEY_C2D_OLD_SS_VER: u32 = 1358974989;
pub const SS_ERROR_LICKEY_C2D_PLATFORM_JUST_4_TRADITIONAL: u32 = 1358974990;
pub const SS_ERROR_LICKEY_C2D_PLATFORM_JUST_4_ANDROID: u32 = 1358974991;
pub const SS_ERROR_LICKEY_BIND_NO_AVAILABLE_LICENSE: u32 = 1358974993;
pub const SS_ERROR_LICKEY_BIND_LICENSE_NOT_START: u32 = 1358974994;
pub const SS_ERROR_LICKEY_BIND_LICENSE_EXPIRED: u32 = 1358974995;
pub const SS_ERROR_LICKEY_BINDING_LIMIT_EXCEEDED: u32 = 1358974996;
pub const SS_ERROR_LICKEY_BOUND_LIMIT_EXCEEDED: u32 = 1358974997;
pub const SS_ERROR_LICKEY_BIND_NO_AVAILABLE_PKG: u32 = 1358974998;
pub const SS_ERROR_LICKEY_TERMINAL_UNBIND: u32 = 1358975000;
pub const SS_ERROR_LICKEY_TERMINAL_NOT_EXIST: u32 = 1358975001;
pub const SS_ERROR_LICKEY_C2D_PKG_TYPE: u32 = 1358975008;
pub const SS_ERROR_LICKEY_LICENSE_LOCKED: u32 = 1358975009;
pub const SS_ERROR_LICKEY_DOES_NOT_ALLOW_BIND: u32 = 1358975013;
pub const SS_ERROR_LICKEY_PASSWD_ENABLE: u32 = 1358975024;
pub const SS_ERROR_LICKEY_PASSWD_ERROR: u32 = 1358975025;
pub const SS_ERROR_BORROW_KEY_DISABLE: u32 = 1358975026;
pub const SS_ERROR_LICKEY_CLIENT_OUTDATED_VERSION: u32 = 1358975027;
pub const SS_ERROR_LICKEY_DEVICE_FORBIDDEN: u32 = 1358975028;
pub const SS_ERROR_LICKEY_NOT_EXIST_V2: u32 = 1358979375;
pub const SS_ERROR_LICKEY_INVALID_C2D_DATA: u32 = 1358979376;
pub const SS_ERROR_LICKEY_ABNORMAL_COST: u32 = 1358979380;
pub const SS_ERROR_BORROW_KEY_NOT_EXIST: u32 = 1358975014;
pub const SS_ERROR_BORROW_KEY_DELETED: u32 = 1358975015;
pub const SS_ERROR_BORROW_KEY_ALREADY_REVOKED: u32 = 1358975016;
pub const SS_ERROR_BORROW_KEY_EXPIRED: u32 = 1358975017;
pub const SS_ERROR_BORROW_KEY_ALREADY_BOUND: u32 = 1358975018;
pub const SS_ERROR_BORROW_KEY_BIND_FAILED: u32 = 1358975019;
pub const SS_ERROR_BORROW_KEY_BIND_NOT_EXIST: u32 = 1358975020;
pub const SS_ERROR_BORROW_KEY_UNMATCHED_MACHINE_ID: u32 = 1358975021;
pub const SS_ERROR_BORROW_KEY_MAKE_PACKAGE_FAILED: u32 = 1358975022;
pub const SS_ERROR_WEB_SERVER_INIT_FAILED: u32 = 1879048192;
pub const SS_ERROR_WEB_INVALID_URI: u32 = 1879048193;
pub const SS_ERROR_MAKE_P7B: u32 = 1879048194;
pub const LED_COLOR_BLUE: u32 = 0;
pub const LED_COLOR_RED: u32 = 1;
pub const LED_STATE_CLOSE: u32 = 0;
pub const LED_STATE_OPEN: u32 = 1;
pub const LED_STATE_SHRINK: u32 = 2;
pub const SS_ANTI_INFORMATION: u32 = 257;
pub const SS_ANTI_WARNING: u32 = 258;
pub const SS_ANTI_EXCEPTION: u32 = 259;
pub const SS_ANTI_IDLE: u32 = 260;
pub const SS_MSG_SERVICE_START: u32 = 512;
pub const SS_MSG_SERVICE_STOP: u32 = 513;
pub const SS_MSG_LOCK_AVAILABLE: u32 = 514;
pub const SS_MSG_LOCK_UNAVAILABLE: u32 = 515;
pub const SS_MSG_CLOUD_USER_LOGIN: u32 = 516;
pub const SS_MSG_CLOUD_USER_LOGOUT: u32 = 517;
pub const SS_ANTI_PATCH_INJECT: u32 = 513;
pub const SS_ANTI_MODULE_INVALID: u32 = 514;
pub const SS_ANTI_ATTACH_FOUND: u32 = 515;
pub const SS_ANTI_THREAD_INVALID: u32 = 516;
pub const SS_ANTI_THREAD_ERROR: u32 = 517;
pub const SS_ANTI_CRC_ERROR: u32 = 518;
pub const SS_ANTI_DEBUGGER_FOUND: u32 = 519;
pub const SLM_FIXTIME_RAND_LENGTH: u32 = 8;
pub const SLM_CALLBACK_VERSION02: u32 = 2;
pub const SLM_MEM_MAX_SIZE: u32 = 2048;
pub const SLM_MAX_INPUT_SIZE: u32 = 1758;
pub const SLM_MAX_OUTPUT_SIZE: u32 = 1758;
pub const SLM_MAX_USER_CRYPT_SIZE: u32 = 1520;
pub const SLM_MAX_USER_DATA_SIZE: u32 = 2048;
pub const SLM_MAX_WRITE_SIZE: u32 = 1904;
pub const SLM_VERIFY_DEVICE_PREFIX: &[u8; 10] = b"SENSELOCK\0";
pub const SLM_VERIFY_DATA_SIZE: u32 = 41;
pub const SLM_LOCK_SN_LENGTH: u32 = 16;
pub const SLM_DEVELOPER_ID_SIZE: u32 = 8;
pub const SLM_MAX_SERVER_NAME: u32 = 32;
pub const SLM_MAX_ACCESS_TOKEN_LENGTH: u32 = 64;
pub const SLM_MAX_CLOUD_SERVER_LENGTH: u32 = 100;
pub const SLM_SNIPPET_SEED_LENGTH: u32 = 32;
pub const SLM_DEV_PASSWORD_LENGTH: u32 = 16;
pub const SLM_CLOUD_MAX_USER_GUID_SIZE: u32 = 128;
pub const SLM_GUID_LENGTH: u32 = 16;
pub const SLM_FILE_TYPE_BINARY: u32 = 0;
pub const SLM_FILE_TYPE_EXECUTIVE: u32 = 1;
pub const SLM_FILE_TYPE_KEY: u32 = 2;
pub const SLM_FILE_PRIVILEGE_FLAG_READ: u32 = 1;
pub const SLM_FILE_PRIVILEGE_FLAG_WRITE: u32 = 2;
pub const SLM_FILE_PRIVILEGE_FLAG_USE: u32 = 4;
pub const SLM_FILE_PRIVILEGE_FLAG_UPDATE: u32 = 8;
pub const SLM_FILE_PRIVILEGE_FLAG_ENTRY_READ: u32 = 16;
pub const SLM_FILE_PRIVILEGE_FLAG_ENTRY_WRITE: u32 = 32;
pub const SLM_FILE_PRIVILEGE_FLAG_ENTRY_USE: u32 = 64;
pub const SLM_FILE_PRIVILEGE_FLAG_ENTRY_UPDATE: u32 = 128;
pub const SLM_LOGIN_MODE_AUTO: u32 = 0;
pub const SLM_LOGIN_MODE_LOCAL_DONGLE: u32 = 1;
pub const SLM_LOGIN_MODE_REMOTE_DONGLE: u32 = 2;
pub const SLM_LOGIN_MODE_CLOUD: u32 = 4;
pub const SLM_LOGIN_MODE_LOCAL_SLOCK: u32 = 8;
pub const SLM_LOGIN_MODE_REMOTE_SLOCK: u32 = 16;
pub const SLM_LOGIN_FLAG_FIND_ALL: u32 = 1;
pub const SLM_LOGIN_FLAG_VERSION: u32 = 4;
pub const SLM_LOGIN_FLAG_LOCKSN: u32 = 8;
pub const SLM_LOGIN_FLAG_SERVER: u32 = 16;
pub const SLM_LOGIN_FLAG_SNIPPET: u32 = 32;
pub const LANGUAGE_CHINESE_ASCII: u32 = 1;
pub const LANGUAGE_ENGLISH_ASCII: u32 = 2;
pub const LANGUAGE_TRADITIONAL_CHINESE_ASCII: u32 = 3;
pub const SLM_INIT_FLAG_NOTIFY: u32 = 1;
pub const SLM_MAC_SIZE: u32 = 6;
pub const SLM_MAX_CPU_INFO_SIZE: u32 = 128;
pub const SLM_MAX_BIOS_INFO_SIZE: u32 = 128;
pub const SLM_MAX_SESSION_ID_SIZE: u32 = 32;
pub type SS_UINT64 = ::std::os::raw::c_ulonglong;
pub type SS_UINT32 = ::std::os::raw::c_uint;
pub type SS_UINT16 = ::std::os::raw::c_ushort;
pub type SS_UINT8 = ::std::os::raw::c_uchar;
pub type SS_INT64 = ::std::os::raw::c_longlong;
pub type SS_INT32 = ::std::os::raw::c_int;
pub type SS_INT16 = ::std::os::raw::c_short;
pub type SS_INT8 = ::std::os::raw::c_char;
pub type SS_BYTE = ::std::os::raw::c_uchar;
pub type SS_CHAR = ::std::os::raw::c_char;
pub type SS_BOOL = ::std::os::raw::c_int;
#[doc = " JSON��ʽ"]
pub const _INFO_FORMAT_TYPE_JSON: _INFO_FORMAT_TYPE = 2;
#[doc = " �ṹ���ʽ"]
pub const _INFO_FORMAT_TYPE_STRUCT: _INFO_FORMAT_TYPE = 3;
#[doc = "  �\u{5b7}���ģʽ,����Key=value"]
pub const _INFO_FORMAT_TYPE_STRING_KV: _INFO_FORMAT_TYPE = 4;
#[doc = " ���\u{736}����Ƹ�ʽ"]
pub const _INFO_FORMAT_TYPE_CIPHER: _INFO_FORMAT_TYPE = 5;
#[doc = " ������ʽö��"]
pub type _INFO_FORMAT_TYPE = ::std::os::raw::c_uint;
#[doc = " ������ʽö��"]
pub use self::_INFO_FORMAT_TYPE as INFO_FORMAT_TYPE;
#[doc = " \u{5a4}�����\u{363}���\u{5a4}��"]
pub const _CERT_TYPE_CERT_TYPE_ROOT_CA: _CERT_TYPE = 0;
#[doc = " \u{5a4}�����\u{363}��豸��CA"]
pub const _CERT_TYPE_CERT_TYPE_DEVICE_CA: _CERT_TYPE = 1;
#[doc = " \u{5a4}�����\u{363}��豸\u{5a4}��"]
pub const _CERT_TYPE_CERT_TYPE_DEVICE_CERT: _CERT_TYPE = 2;
#[doc = " \u{5a4}�����\u{363}���˼�豸\u{5a4}��"]
pub const _CERT_TYPE_CERT_TYPE_SENSE_DEVICE_CERT: _CERT_TYPE = 3;
#[doc = " �豸\u{5a4}������"]
pub type _CERT_TYPE = ::std::os::raw::c_uint;
#[doc = " �豸\u{5a4}������"]
pub use self::_CERT_TYPE as CERT_TYPE;
#[doc = " Virbox���ɷ��� ��Ϣ�����ص���������ǰ�汾 SLM_CALLBACK_VERSION02 ) ������lparam��ʱû��ʹ��"]
pub type SS_CALL_BACK = ::std::option::Option<
    unsafe extern "C" fn(
        message: SS_UINT32,
        wparam: *mut ::std::os::raw::c_void,
        lparam: *mut ::std::os::raw::c_void,
    ) -> SS_UINT32,
>;
#[doc = " ���ɵ�¼����ڴ���������Ҫ�ͻ�ά���ڴ棬Virbox���ɷ��� �濪����ά���ڴ棬����һ���ڴ�id����Χ��0-N\u{5ae}��"]
pub type SLM_HANDLE_INDEX = ::std::os::raw::c_uint;
#[doc = "  Ӳ��������Ϣ"]
pub const _INFO_TYPE_LOCK_INFO: _INFO_TYPE = 1;
#[doc = "  �������ɵĻỰ��Ϣ"]
pub const _INFO_TYPE_SESSION_INFO: _INFO_TYPE = 2;
#[doc = "  ��ǰ��¼��������Ϣ"]
pub const _INFO_TYPE_LICENSE_INFO: _INFO_TYPE = 3;
#[doc = "  �����ļ��б�"]
pub const _INFO_TYPE_FILE_LIST: _INFO_TYPE = 4;
#[doc = " �������Ϣ����ö��"]
pub type _INFO_TYPE = ::std::os::raw::c_uint;
#[doc = " �������Ϣ����ö��"]
pub use self::_INFO_TYPE as INFO_TYPE;
#[doc = " \u{5bb}����"]
pub const _LIC_USER_DATA_TYPE_ROM: _LIC_USER_DATA_TYPE = 0;
#[doc = " ��д��"]
pub const _LIC_USER_DATA_TYPE_RAW: _LIC_USER_DATA_TYPE = 1;
#[doc = " ������"]
pub const _LIC_USER_DATA_TYPE_PUB: _LIC_USER_DATA_TYPE = 2;
#[doc = " ��������������ö��"]
pub type _LIC_USER_DATA_TYPE = ::std::os::raw::c_uint;
#[doc = " ��������������ö��"]
pub use self::_LIC_USER_DATA_TYPE as LIC_USER_DATA_TYPE;
pub const _ENUM_DESC_TYPE_ENUM_DESC_LOCAL_DONGLE: _ENUM_DESC_TYPE = 0;
pub const _ENUM_DESC_TYPE_ENUM_DESC_REMOTE_DONGLE: _ENUM_DESC_TYPE = 1;
pub const _ENUM_DESC_TYPE_ENUM_DESC_CLOUD: _ENUM_DESC_TYPE = 2;
pub const _ENUM_DESC_TYPE_ENUM_DESC_SMART_OFFLINE: _ENUM_DESC_TYPE = 3;
pub const _ENUM_DESC_TYPE_ENUM_DESC_LOCAL_SLOCK: _ENUM_DESC_TYPE = 4;
pub const _ENUM_DESC_TYPE_ENUM_DESC_REMOTE_SLOCK: _ENUM_DESC_TYPE = 5;
#[doc = " �豸��������"]
pub type _ENUM_DESC_TYPE = ::std::os::raw::c_uint;
#[doc = " �豸��������"]
pub use self::_ENUM_DESC_TYPE as ENUM_DESV_TYPE;
#[doc = " Ӳ�������ƿ��ƽṹ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_LED_CONTROL {
    #[doc = "  0��ʾ��ɫLED��1��ʾ��ɫLED���ο��꣺LEX_COLOR_XXX"]
    pub index: SS_UINT32,
    #[doc = "  0�����رգ�1�����\u{bfaa3}� 2������˸���ο��꣺LED_STATE_XXX"]
    pub state: SS_UINT32,
    #[doc = "  LED����˸ʱ���������룩"]
    pub interval: SS_UINT32,
}
#[test]
fn bindgen_test_layout__ST_LED_CONTROL() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_LED_CONTROL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_LED_CONTROL>(),
        12usize,
        concat!("Size of: ", stringify!(_ST_LED_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_LED_CONTROL>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_LED_CONTROL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LED_CONTROL),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LED_CONTROL),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LED_CONTROL),
            "::",
            stringify!(interval)
        )
    );
}
#[doc = " Ӳ�������ƿ��ƽṹ"]
pub type ST_LED_CONTROL = _ST_LED_CONTROL;
#[doc = " ��ʼ������"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_INIT_PARAM {
    #[doc = " �汾���������ݣ���ǰʹ�� SLM_CALLBACK_VERSION02"]
    pub version: SS_UINT32,
    #[doc = " �����Ҫ���� Virbox���ɷ��� \u{368}\u{5aa}���� SLM_INIT_FLAG_NOTIFY"]
    pub flag: SS_UINT32,
    #[doc = " �ص�����\u{5b8}��"]
    pub pfn: SS_CALL_BACK,
    #[doc = " \u{368}�����ӳ�ʱʱ�䣨���룩�������0����ʹ��Ĭ�ϳ�ʱʱ�䣨7�룩"]
    pub timeout: SS_UINT32,
    #[doc = " API���룬�ɴ� VirboxLM �ƿ��������ģ�https://developer.lm.virbox.com����\u{368}�����鿴��������Ϣ����ȡ"]
    pub password: [SS_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__ST_INIT_PARAM() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_INIT_PARAM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_INIT_PARAM>(),
        40usize,
        concat!("Size of: ", stringify!(_ST_INIT_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_INIT_PARAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_ST_INIT_PARAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_INIT_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_INIT_PARAM),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_INIT_PARAM),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_INIT_PARAM),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_INIT_PARAM),
            "::",
            stringify!(password)
        )
    );
}
#[doc = " ��ʼ������"]
pub type ST_INIT_PARAM = _ST_INIT_PARAM;
#[doc = " ����Login �ṹ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_LOGIN_PARAM {
    #[doc = " �ṹ���С�����\u{e8e9}"]
    pub size: SS_UINT32,
    #[doc = " Ҫ��¼������ID"]
    pub license_id: SS_UINT32,
    #[doc = " ���ɻỰ�ĳ�ʱʱ�䣨��λ���룩,��0��ʹ��Ĭ��\u{5b5}��600��"]
    pub timeout: SS_UINT32,
    #[doc = " ���ɵ�¼��ģʽ��������������������������������SLM_LOGIN_MODE_XXX)�������0����ʹ��SLM_LOGIN_MODE_AUTO"]
    pub login_mode: SS_UINT32,
    #[doc = " ���ɵ�¼�ı�־����SLM_LOGIN_FLAG_XXX����������;�������ô˲���"]
    pub login_flag: SS_UINT32,
    #[doc = " ���ɵ�¼\u{5b8}������Ψһ���кţ������ƣ�����ѡ��"]
    pub sn: [SS_BYTE; 16usize],
    #[doc = " ��������������\u{5b7}����ѡ������ʶ��IP��\u{5b7}"]
    pub server: [SS_CHAR; 32usize],
    #[doc = " �����û�token����ѡ��"]
    pub access_token: [SS_CHAR; 64usize],
    #[doc = " ������������\u{5b7}����ѡ��"]
    pub cloud_server: [SS_CHAR; 100usize],
    #[doc = " ��Ƭ�������ӣ���ѡ�������Ҫ\u{5a7}����Ƭ����,login_flag��Ҫ\u{5b8}��ΪSLM_LOGIN_FLAG_SNIPPET"]
    pub snippet_seed: [SS_BYTE; 32usize],
    #[doc = " �ѵ�¼�û��� guid �\u{b1fb5}��Ѱ\u{f6a35}����� guid���\u{5b7}���������ѡ��"]
    pub user_guid: [SS_CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__ST_LOGIN_PARAM() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_LOGIN_PARAM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_LOGIN_PARAM>(),
        392usize,
        concat!("Size of: ", stringify!(_ST_LOGIN_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_LOGIN_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_LOGIN_PARAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).license_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(license_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).login_mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(login_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).login_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(login_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(sn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_token) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(access_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloud_server) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(cloud_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snippet_seed) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(snippet_seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_guid) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOGIN_PARAM),
            "::",
            stringify!(user_guid)
        )
    );
}
#[doc = " ����Login �ṹ"]
pub type ST_LOGIN_PARAM = _ST_LOGIN_PARAM;
#[doc = " ����Ϣ�ṹ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_LOCK_INFO {
    #[doc = "  �ṹ���С"]
    pub size: SS_UINT32,
    #[doc = "  �豸���\u{363}�0 = ��\u{368}�û�����2 = ʱ���û���"]
    pub device_type: SS_UINT8,
    #[doc = "  �豸�ͺ�, 0 = ����5�û���"]
    pub device_mode: SS_UINT8,
    #[doc = "  ����"]
    pub res: SS_UINT16,
    #[doc = "  Entry �\u{33c}��汾���û����ع��ģ�"]
    pub lmfirm_version: [SS_UINT8; 4usize],
    #[doc = "  H5 �\u{33c}��汾���������жϼ������\u{33c}��汾"]
    pub h5firm_version: SS_UINT32,
    #[doc = "  Ӳ���汾���û����ع��ģ�"]
    pub hardware_version: SS_UINT32,
    #[doc = "  �������ڣ�UTC��"]
    pub manufacture_date: SS_UINT32,
    #[doc = "  �\u{739}��ռ䣨��λ���\u{5bd}ڣ�"]
    pub total_space: SS_UINT32,
    #[doc = "  ʣ��ռ䣨��λ���\u{5bd}ڣ�"]
    pub available_space: SS_UINT32,
    #[doc = "  \u{368}ѶЭ�飨�û����ع��ģ�"]
    pub protocol: SS_UINT32,
    #[doc = "  ���ߵ�\u{5b7}���û����ع��ģ�"]
    pub slave_addr: SS_UINT32,
    #[doc = "  ����ʱ�ӣ�UTC��"]
    pub clock: SS_UINT32,
    #[doc = "  0 = ����ʱ�ӣ�2 = Ӳ��ʱ��"]
    pub clock_type: SS_UINT32,
    #[doc = "  ʱ���������������Ӳ��ʱ����Ч������5ʱ�������У�"]
    pub drop_times: SS_UINT32,
    #[doc = "  ��оƬ���кţ���ʶΨһ��"]
    pub lock_sn: [SS_BYTE; 16usize],
    #[doc = "  ���ı��������û��������洢����Ǳ�ţ�Ҳ�ɱ�ʶΨһ��"]
    pub user_info: [SS_BYTE; 128usize],
    #[doc = "  ���ı��������ڲ�����"]
    pub inner_info: [SS_BYTE; 128usize],
    #[doc = "  0 = ��\u{5a7}�\u{5b9}�����1 = \u{5a7}�\u{5b9}���"]
    pub shared_enabled: SS_UINT32,
    #[doc = "  �������������ߣ�������ID��"]
    pub owner_developer_id: [SS_BYTE; 8usize],
}
#[test]
fn bindgen_test_layout__ST_LOCK_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_LOCK_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_LOCK_INFO>(),
        336usize,
        concat!("Size of: ", stringify!(_ST_LOCK_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_LOCK_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_LOCK_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_mode) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(device_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lmfirm_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(lmfirm_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h5firm_version) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(h5firm_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardware_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(hardware_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manufacture_date) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(manufacture_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_space) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(total_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available_space) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(available_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slave_addr) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(slave_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_type) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(clock_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drop_times) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(drop_times)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_sn) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(lock_sn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_info) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(user_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_info) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(inner_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_enabled) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(shared_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_developer_id) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LOCK_INFO),
            "::",
            stringify!(owner_developer_id)
        )
    );
}
#[doc = " ����Ϣ�ṹ"]
pub type ST_LOCK_INFO = _ST_LOCK_INFO;
#[doc = " �Ự��Ϣ�ṹ��"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ST_SESSION_INFO {
    #[doc = "  �����С"]
    pub size: SS_UINT32,
    #[doc = "  �Ѿ���¼������id"]
    pub license_id: SS_UINT32,
    pub __bindgen_anon_1: _ST_SESSION_INFO__bindgen_ty_1,
    #[doc = "  ���������õĻỰ time_out"]
    pub app_time_out: SS_UINT32,
    #[doc = "  ��ǰ�����Ľ��� id"]
    pub app_process_id: SS_UINT32,
    #[doc = "  ����MAC��\u{5b7}"]
    pub mac: [SS_UINT8; 6usize],
    pub session_id: [::std::os::raw::c_char; 32usize],
    #[doc = "  CPU ID Verndor ��Ϣ"]
    pub cpuinfo: [::std::os::raw::c_char; 128usize],
    #[doc = "  BIOS��Ϣ �������Ƶ�"]
    pub bios: [::std::os::raw::c_char; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ST_SESSION_INFO__bindgen_ty_1 {
    pub sn: [SS_BYTE; 16usize],
    pub user_guid: [SS_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__ST_SESSION_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_SESSION_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_SESSION_INFO__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_ST_SESSION_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_SESSION_INFO__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_ST_SESSION_INFO__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO__bindgen_ty_1),
            "::",
            stringify!(sn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO__bindgen_ty_1),
            "::",
            stringify!(user_guid)
        )
    );
}
#[test]
fn bindgen_test_layout__ST_SESSION_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_SESSION_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_SESSION_INFO>(),
        328usize,
        concat!("Size of: ", stringify!(_ST_SESSION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_SESSION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_SESSION_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).license_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(license_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_time_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(app_time_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_process_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(app_process_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuinfo) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(cpuinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bios) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SESSION_INFO),
            "::",
            stringify!(bios)
        )
    );
}
#[doc = " �Ự��Ϣ�ṹ��"]
pub type ST_SESSION_INFO = _ST_SESSION_INFO;
#[doc = " ������Ϣ�ṹ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_SLM_LICENSE_INFO {
    #[doc = "  �ṹ���С"]
    pub size: SS_UINT32,
    #[doc = "  ���ɰ汾��"]
    pub lic_ver: SS_UINT32,
    #[doc = "  ���ɱ�־λ��ע����Ҫ�Ķ�flag��ƫ�ƣ�"]
    pub flag: [SS_BYTE; 4usize],
    #[doc = "  ���ɵ�guid"]
    pub guid: [SS_BYTE; 16usize],
    #[doc = "  ����ID"]
    pub lic_id: SS_UINT32,
    #[doc = "  ��ʼʱ��"]
    pub start_time: SS_UINT32,
    #[doc = "  ��\u{5b9}ʱ��"]
    pub end_time: SS_UINT32,
    #[doc = "  ʱ����"]
    pub span_time: SS_UINT32,
    #[doc = "  ����ʱ���"]
    pub time_stamp: SS_UINT32,
    #[doc = "  ������ˮ��"]
    pub serial: SS_UINT16,
    #[doc = "  ������\u{f28b7}���"]
    pub concurrency: SS_UINT16,
    #[doc = "  ����������"]
    pub count: SS_UINT32,
    #[doc = "  ģ�鹦�\u{731}�ʶλ"]
    pub module_bit: SS_UINT64,
    #[doc = "  ����ʱ��"]
    pub lock_time: SS_UINT32,
    #[doc = "  ��һ��ʹ��ʱ��"]
    pub first_use_time: SS_UINT32,
    #[doc = "  ��ǰʣ�����"]
    pub curr_count: SS_UINT32,
    #[doc = "  ������ʱ��"]
    pub offline_period: SS_UINT32,
    #[doc = "  ����\u{36c}ʱʹ�õĻ���������������\u{7b9}أ�\u{5bb}�������й�"]
    pub bind_node: SS_UINT32,
    #[doc = "  ���ɰ\u{f6a35}Ļ���������������йأ�һ���\u{f6a23}��������"]
    pub max_bind_node: SS_UINT32,
    #[doc = "  ��д����С"]
    pub raw_size: SS_UINT32,
    #[doc = "  \u{5bb}������С"]
    pub rom_size: SS_UINT32,
    #[doc = "  ��������С"]
    pub pub_size: SS_UINT32,
}
#[test]
fn bindgen_test_layout__ST_SLM_LICENSE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_SLM_LICENSE_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_SLM_LICENSE_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(_ST_SLM_LICENSE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_SLM_LICENSE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_ST_SLM_LICENSE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lic_ver) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(lic_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lic_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(lic_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_time) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).span_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(span_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_stamp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(time_stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrency) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(concurrency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_bit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(module_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(lock_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_use_time) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(first_use_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(curr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offline_period) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(offline_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bind_node) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(bind_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bind_node) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(max_bind_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(raw_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rom_size) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(rom_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pub_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_SLM_LICENSE_INFO),
            "::",
            stringify!(pub_size)
        )
    );
}
#[doc = " ������Ϣ�ṹ"]
pub type ST_SLM_LICENSE_INFO = _ST_SLM_LICENSE_INFO;
#[doc = " �ļ���Ϣ�ṹ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_FILE_INFO {
    #[doc = " ��־��Щ����Ч�����������ļ�������ʹ��"]
    pub validate: SS_BYTE,
    #[doc = " �ļ����\u{363}������\u{7b8}�"]
    pub type_: SS_BYTE,
    #[doc = " �ļ�����Ȩ��"]
    pub pri: SS_UINT16,
    #[doc = " �ļ���С"]
    pub size: SS_UINT32,
    #[doc = " �ļ��\u{7b8}�ʱ��"]
    pub time: SS_UINT32,
    #[doc = " �ļ���  ��ǰ�ļ����Ƴ���16�\u{5bd}�"]
    pub name: [SS_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__ST_FILE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_FILE_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_FILE_INFO>(),
        28usize,
        concat!("Size of: ", stringify!(_ST_FILE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_FILE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_FILE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " �ļ���Ϣ�ṹ"]
pub type ST_FILE_INFO = _ST_FILE_INFO;
#[doc = " �ļ���Ϣ�ṹ�б�"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_FILE_INFO_LIST {
    #[doc = " ��ǰΪ1"]
    pub version: SS_UINT32,
    pub count: SS_UINT32,
    pub info: [ST_FILE_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__ST_FILE_INFO_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_FILE_INFO_LIST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_FILE_INFO_LIST>(),
        36usize,
        concat!("Size of: ", stringify!(_ST_FILE_INFO_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_FILE_INFO_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_FILE_INFO_LIST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO_LIST),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_FILE_INFO_LIST),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " �ļ���Ϣ�ṹ�б�"]
pub type ST_FILE_INFO_LIST = _ST_FILE_INFO_LIST;
#[doc = " �豸��Ϣ�ṹ"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ST_DEV_INFO {
    #[doc = "\tlocal, remote or cloud.(DESC type)"]
    pub desc_type: SS_UINT16,
    #[doc = "  LM���\u{363}�LM_FIRM_TYPE_XXX)"]
    pub firm_type: SS_UINT16,
    pub developer_id: [SS_BYTE; 8usize],
    pub __bindgen_anon_1: _ST_DEV_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ST_DEV_INFO__bindgen_ty_1 {
    pub cloud: _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1,
    pub smart_offline: _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1,
    pub h5: _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2,
    pub slock: _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub cloud_server: [SS_CHAR; 114usize],
    pub user_token: [SS_CHAR; 48usize],
    pub user_guid: [SS_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1>(),
        178usize,
        concat!(
            "Size of: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloud_server) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cloud_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_token) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(user_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_guid) as usize - ptr as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(user_guid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2 {
    pub serial: [SS_BYTE; 16usize],
    pub ip: [SS_CHAR; 64usize],
    pub port: SS_UINT16,
    pub host_name: [SS_CHAR; 32usize],
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2>(),
        114usize,
        concat!(
            "Size of: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(host_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3 {
    pub user_guid: [SS_BYTE; 16usize],
    pub ip: [SS_CHAR; 64usize],
    pub port: SS_UINT16,
    pub host_name: [SS_CHAR; 32usize],
    pub account_name: [SS_CHAR; 64usize],
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3>(),
        178usize,
        concat!(
            "Size of: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(user_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account_name) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(account_name)
        )
    );
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO__bindgen_ty_1>(),
        178usize,
        concat!("Size of: ", stringify!(_ST_DEV_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_ST_DEV_INFO__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloud) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1),
            "::",
            stringify!(cloud)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smart_offline) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1),
            "::",
            stringify!(smart_offline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1),
            "::",
            stringify!(h5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO__bindgen_ty_1),
            "::",
            stringify!(slock)
        )
    );
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO>(),
        190usize,
        concat!("Size of: ", stringify!(_ST_DEV_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(_ST_DEV_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO),
            "::",
            stringify!(desc_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firm_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO),
            "::",
            stringify!(firm_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).developer_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO),
            "::",
            stringify!(developer_id)
        )
    );
}
#[doc = " �豸��Ϣ�ṹ"]
pub type ST_DEV_INFO = _ST_DEV_INFO;
#[doc = " �豸�����ṹ"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ST_ENUM_DEVICE {
    pub dev_info: ST_DEV_INFO,
    pub lock_info: ST_LOCK_INFO,
}
#[test]
fn bindgen_test_layout__ST_ENUM_DEVICE() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_ENUM_DEVICE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_ENUM_DEVICE>(),
        528usize,
        concat!("Size of: ", stringify!(_ST_ENUM_DEVICE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_ENUM_DEVICE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_ENUM_DEVICE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_ENUM_DEVICE),
            "::",
            stringify!(dev_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_info) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_ENUM_DEVICE),
            "::",
            stringify!(lock_info)
        )
    );
}
#[doc = " �豸�����ṹ"]
pub type ST_ENUM_DEVICE = _ST_ENUM_DEVICE;
#[doc = " �豸��Ϣ�б�"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ST_DEV_INFO_LIST {
    pub version: SS_UINT32,
    pub count: SS_UINT32,
    pub info: [ST_ENUM_DEVICE; 1usize],
}
#[test]
fn bindgen_test_layout__ST_DEV_INFO_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_DEV_INFO_LIST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_DEV_INFO_LIST>(),
        536usize,
        concat!("Size of: ", stringify!(_ST_DEV_INFO_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_DEV_INFO_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_DEV_INFO_LIST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO_LIST),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_DEV_INFO_LIST),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " �豸��Ϣ�б�"]
pub type ST_DEV_INFO_LIST = _ST_DEV_INFO_LIST;
#[doc = " ����id�б�"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_LICENSE_IDS {
    pub count: SS_UINT32,
    pub lic_ids: [SS_UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__ST_LICENSE_IDS() {
    const UNINIT: ::std::mem::MaybeUninit<_ST_LICENSE_IDS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ST_LICENSE_IDS>(),
        8usize,
        concat!("Size of: ", stringify!(_ST_LICENSE_IDS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ST_LICENSE_IDS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ST_LICENSE_IDS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LICENSE_IDS),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lic_ids) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ST_LICENSE_IDS),
            "::",
            stringify!(lic_ids)
        )
    );
}
#[doc = " ����id�б�"]
pub type ST_LICENSE_IDS = _ST_LICENSE_IDS;
extern "C" {
    #[doc = "   @brief      Runtime API ��ʼ���������������� Runtime API �����ȵ��ô˺������г�ʼ��\n   @param[in]  pst_init    ��ʼ���������� #ST_INIT_PARAM �ṹ����\n   @return     �ɹ�����SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    #slm_init ������ Virbox Runtime API �ĳ�ʼ����������ʹ������ Virbox Runtime API \u{5ae}ǰ������Ҫ�ȵ��ô˺�����\n               ��ʼ��������Ҫ�Ƕ� Runtime �����ĳ�ʼ�����������������Ի��ơ�\n               �ر�˵����\n                   ���ǲ��������ڱ�д Windows ��\u{32c}���ӿ����ʱ���� DllMain �����е��� slm_init �� slm_cleanup����Ϊ���������������ڲ����ú��˳��\u{7f3}\u{323}�\n                   ����п��\u{73b}�������Ķ�\u{32c}���ӿ��ڼ��ص�ʱ����Ϊ����ϵͳ��Դ��ռ������������\u{7f3}��������Ӷ���ɳ�����й©�������������\n                   ���� Windows Ӧ�ó����л�� DllMain ������ʹ�������������\u{b2ef4}��ڴ����⡣���⣬�� Windows ����ϵͳ������ϵͳ����Linux ϵͳ�µ� so �⣩\n                   �Ķ�\u{32c}���ӿ�Ҳ�����ڴ����⡣\n   @see        ST_INIT_PARAM slm_cleanup"]
    pub fn slm_init(pst_init: *mut ST_INIT_PARAM) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ����������Ϣ(����Ӳ������Ч)\n   @param[in]  license_id      Ҫ���ҵ�����ID��0--0xFFFFFFFF��\n   @param[in]  format          ������ʽ���ο� #INFO_FORMAT_TYPE ��Ŀǰ��\u{5a7}�� #JSON �� #STRUCT\n   @param[out] license_desc    ����������Ϣ��\u{5b8}�룬��ʽ�� format \u{5b8}��������� #slm_free �ͷ�\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    �˺������ڲ��ұ���������������������Ϣ������ɹ�����Ҫ���� #slm_free �ͷ� license_desc��\n               �� format = #STRUCT ʱ license_desc ������ �ο� #ST_DEV_INFO_LIST\n   @see        INFO_FORMAT_TYPE"]
    pub fn slm_find_license(
        license_id: SS_UINT32,
        format: INFO_FORMAT_TYPE,
        license_desc: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ö���ѵ�¼���û� token\n   @param[out] access_token    Ĭ���û��� token������� #slm_free �ͷ�\n   @return     �ɹ����� SS_OK����� oauth ��\u{328}����δ�������\u{b7d7b}� SS_ERROR_BAD_CONNECT\n   @remarks    ����ɹ�����Ҫ���� #slm_free �ͷ� access_token"]
    pub fn slm_get_cloud_token(access_token: *mut *mut SS_CHAR) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��ȫ��¼����,�� #JSON ���ݲ���,���Ҽ��ʱ�䣨�Ƿ��ڻ����Ƿ����ڿ�ʼʱ�䣩���������������Ƿ���㣬\n               ����м��������������Լ��ٶ�Ӧ�ļ���������������������ʱ�������粢����������\n   @param[in]  license_param ��¼�������������������������� licenseid������\u{5b8}����¼���Եȡ�\n   @param[in]  param_format  ���������\u{5b7}������\u{363}���\u{5a7}�� #STRUCT��Ϊȷ����ȫ��SDK�汾��2.1.0.15128\u{5ae}������ɵ�¼������\u{5a7}�� json ��¼�ķ�����\n   @param[out] slm_handle    ���ص�¼\u{5ae}�����ɾ��index\u{5b5},��Χ�� 0-256 \u{5ae}�䡣\n   @param[out] auth          ��\u{5a4} login ���������Ƿ���ȷ���� login �ķ���\u{5b5}���ţ����ź���\u{735}õ������ķ���\u{5b5}����\u{5b9}�ڿ�\u{368}������\u{5b5}�����ҵ����ɵ�¼���ɡ���ʹ�ÿ����� NULL��\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks\n   - #slm_login ������ϸ˵����\n       -# ���Զ����ҿ����������ɾ����\n       -# �� Runtime �������������ڴ�������\u{7f3}���Ϣ��\n       -# �����������Ҫ���ڼ�ػỰ���\u{323}���������������\u{7f1}������Լ��ͷŶ�Ӧ���ڴ��������Դ��\n       -# LM�����ڿͻ������Զ����룬���� RSA��Կ����\u{5a4}�豸ID�������\u{331}�ŵ�һ����\u{5a4}�\u{5b6}Ρ�\n       -# LM�����������붼Ҫ login \u{5ae}�������Ȩ�\u{7b2}��� �����д���ӽ��\u{735}Ȳ�����\n   - ���\u{732}���˵����\n       - ���ýṹ�壺\n       -# �ο� #ST_LOGIN_PARAM �ṹ��ϸ����\n       -# #ST_LOGIN_PARAM::size         �����ṹ���С�������\u{e8ec}����Ϊ����ṹ��Ĵ�С������\u{1df5}�ش��� SS_ERROR_RUNTIME_VERSION\n       -# #ST_LOGIN_PARAM::license_id   ����ID��Ϊ32λ��������ȡ\u{5b5}��Χ 0-4294967295����д����\n       -# #ST_LOGIN_PARAM::login_mode   ���ɵ�¼ģʽ����Ϊ�Զ�ģʽ���Լ��������������������������������\n       -# #ST_LOGIN_PARAM::sn           \u{5b8}����¼���� Ϊ������Ӳ����оƬ�ţ�16�\u{5bd}ڣ���\n       -# #ST_LOGIN_PARAM::access_token �����¼����������Ҫ\u{5b8}��\u{368}�� oauth ��\u{5a4}�� access token\n       -# #ST_LOGIN_PARAM::timeout     \u{5b8}����¼�Ự��ʱ ��λΪ�롣�������д��Ĭ��Ϊ600�룬Ӳ��������������Ĭ����С������ 60s����\u{f2ef5}ó��� 12Сʱ��12 * 60 * 60 �룩��\n       -# #ST_LOGIN_PARAM::user_guid    ��¼�û��� guid����\u{f3936}�Ϊ #SLM_CLOUD_MAX_USER_GUID_SIZE��һ�㲻ʹ�� guid\n   @code\n\t\tvoid test_normal()\n       {\n           SS_UINT32           status = SS_OK;\n           ST_INIT_PARAM       init_param = { SLM_CALLBACK_VERSION02, 0, 0, 20000 };\n           SLM_HANDLE_INDEX    slm_handle = 0;\n           ST_LOGIN_PARAM      login_param = { 0 };\n\n           // psd�Ǳش�������ÿ��������˽�У�����й¶����� VirboxLM �ƿ��������Ļ�ȡ��https://developer.lm.virbox.com\n           const char          psd[] = { 0xDB, 0x3B, 0x83, 0x8B, 0x2E, 0x4F, 0x08, 0xF5, 0xC9, 0xEF, 0xCD, 0x1A, 0x5D, 0xD1, 0x63, 0x41};\n\n           memcpy(init_param.password, psd, sizeof(init_param.password));\n\n           status = slm_init(&init_param);\n           if(status != SS_OK)\n           {\n               return ;\n           }\n\n           login_param.license_id = 0;\n           login_param.size = sizeof(ST_LOGIN_PARAM);      // �ṹ�峤�ȱ��븳\u{5b5}Ϊ��ȷ�ĳ��ȣ���������\n           login_param.login_mode = SLM_LOGIN_MODE_LOCAL;\n\n           status = slm_login(&login_param, STRUCT, &slm_handle, NULL);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n\n           slm_logout(slm_handle);\n       }\n\n\t\tvoid test_login_with_auth()\n\t\t{\n\t\t\tunsigned int sts = SS_OK;\n\t\t\tss_auth_xor_t auth = { 0 };\n\t\t\tint key;\n\n\t\t\ttypedef struct _ss_auth_xor_t\n\t\t\t{\n\t\t\t\tint size;\t\t// �ṹ���С\n\t\t\t\tint r[4];\t\t// ���������\n\t\t\t\tint g[2];\t\t// ��Կ\n\t\t\t} ss_auth_xor_t;\n\n\t\t\t....\n\t\t\tauth.size = sizeof(ss_auth_xor_t);\n\t\t\tfor (int i = 0; i != 4; ++i)\n\t\t\t\tauth[i].r = rand();\n\t\t\tkey = (auth.r[0] + auth.r[1]) ^ (auth.r[2] + auth.r[3]);\n\n\t\t\tsts = slm_login(&login, STRUCT, &slm_handle, &auth);\n\t\t\tkey = key ^ (auth.g[0] + auth.g[1]);\n\t\t\tsts = (sts ^ key);\n\t\t\t....\n\t\t}\n   @endcode\n   @see slm_logout SS_UINT32 INFO_FORMAT_TYPE ST_LOGIN_PARAM"]
    pub fn slm_login(
        license_param: *const ST_LOGIN_PARAM,
        param_format: INFO_FORMAT_TYPE,
        slm_handle: *mut SLM_HANDLE_INDEX,
        auth: *mut ::std::os::raw::c_void,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���ɵǳ��������ͷ����ɾ������Դ\n   @param[in]  slm_handle    ���ɾ��\u{5b5}���� #slm_login �õ�\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ����ʹ������ʱ����Ҫ���� #slm_logout �˳���¼���ɣ�������ռ�� Runtime ���е��ڴ����Դ��\n               ���磬���� Runtime ��\u{5bb}\u{5a7}�����256����¼�������\u{5bb}��¼���ɶ����ǳ����ɣ�һ������ 256 ����¼�㽫ռ������ Runtime ���е���Դ�����º����ĵ�¼ʧ��\n   @see        slm_login"]
    pub fn slm_logout(slm_handle: SLM_HANDLE_INDEX) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���\u{5b5}�¼�Ự�����������Ϊ����ʬ�������\n   @param[in]  slm_handle    ���ɾ��\u{5b5}\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ��ʬ��������������ѭ�����\u{7f1}�����slm_handle �����Զ����ͷţ���� Runtime �����ڴ����Դ�˷�\n   @code\n       DWORD WINAPI __stdcall _ThreadKeepalive(void *pVoid)\n       {\n           SLM_HANDLE_INDEX slm_handle = *(SLM_HANDLE_INDEX *)(pVoid);\n           SS_UINT32        status = SS_OK;\n\n           while (1)\n           {\n               status = slm_keep_alive(slm_handle);\n               if(status != SS_OK)\n               {\n                   //todo do: deal error code\n               }\n               Sleep(1000 * 10);      // ʮ���ӽ���һ���������ӣ���\u{5a4}�Ự����Ч��\n           }\n       }\n\n       {\n           SS_UINT32           status = SS_OK;\n           SLM_HANDLE_INDEX    slm_handle = 0;\n           ST_LOGIN_PARAM      login_param = { 0 };\n           HANDLE hThread;\n           DWORD  id = 0;\n\n           login_param.license_id = 0;\n           login_param.size = sizeof(ST_LOGIN_PARAM);\n           login_param.login_mode = SLM_LOGIN_MODE_LOCAL;\n           login_param.time_out = 30;    // ���ûỰΪ30�볬ʱ\n\n           status = slm_login(&login_param, STRUCT, &slm_handle, NULL);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n\n           hThread = CreateThread(NULL, 0, _ThreadKeepalive, &slm_handle, 0, &id);\n           if (hThread == NULL)\n           {\n               //todo: deal error\n           }\n       }\n   @endcode\n   @see       slm_login"]
    pub fn slm_keep_alive(slm_handle: SLM_HANDLE_INDEX) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���ɼ��ܣ���\u{36c}������ID��\u{36c}�Ŀ����\u{7fc}��\u{73d}����\u{36c}\n   @param[in]  slm_handle   ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  inbuffer     �������뻺����,��Ҫ 16�\u{5bd}� ���룬����\u{733}��� 1520���\u{5bd}ڡ�\n   @param[out] outbuffer    �������������,��Ҫ 16�\u{5bd}� ����\n   @param[in]  len          ���\u{73b}�������С��Ϊ 16 ����������\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ����Ӳ����������\u{5bd}������ޣ���˼ӽ���ʱһ�δ�����\u{5bd}ڲ��ó��� 1520���\u{5bd}ڣ�����Ҫ�ӽ��\u{735}��\u{5bd}������ڴ�������ƣ�\n               �ɲ��ý�ȡ��������ѭ�����õķ�ʽ���мӽ��ܣ��ӽ��\u{73d}�������\u{735}��κ�Ӱ�졣\n   @code\n       {\n           SS_UINT32   status = SS_OK;\n           SS_BYTE     plain[32] = { 0 };  // �ӽ���ʹ��AES�ԳƼ��ܣ��������ݱ���16�\u{5bd}ڶ���\n           SS_BYTE     enc[32] = { 0 };\n           SS_BYTE     dec[32] = { 0 };\n\n           memcpy(data, \"test data...\", strlen(\"test data...\"));\n\n           status = slm_encrypt(slm_handle, plain, enc, sizeof(enc));\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n               return ;\n           }\n\n           status = slm_decrypt(slm_handle, enc, dec, sizeof(dec));\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n               return ;\n           }\n\n           //�ԱȽ��\u{73a}�������Ƿ���������\n           //if(plain == dec)\n           //{\n           //    SUCCESS;\n           //}\n           //else\n           //{\n           //    FAILURE;\n           //}\n       }\n   @endcode\n   @see        slm_encrypt slm_decrypt slm_login"]
    pub fn slm_encrypt(
        slm_handle: SLM_HANDLE_INDEX,
        inbuffer: *mut SS_BYTE,
        outbuffer: *mut SS_BYTE,
        len: SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���ɽ��ܣ���\u{36c}������ID��\u{36c}�Ŀ����\u{7fc}��\u{73d}����\u{36c}\n   @param[in]  slm_handle   ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  inbuffer     �������뻺����,��Ҫ 16�\u{5bd}� ���롣����\u{733}��� 1520���\u{5bd}ڡ�\n   @param[out] outbuffer    �������������,��Ҫ 16�\u{5bd}� ����\n   @param[in]  len          ���\u{73b}�������С��Ϊ 16 ����������\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ���\u{737}�ʽ���� AES�ԳƼ��ܣ���Կ�ڼ������ڣ�\u{5b8}Ӳ��������������������\u{36c}�����ɣ���û���κλ����\u{733}������ڱ�\u{5a4}Ч�ʵ�\u{36c}ʱ��Ҳ��\u{fbbf5}ļ�ǿ�˰�ȫ�ԡ�\n               ����Ӳ����������\u{5bd}������ޣ���˼ӽ���ʱһ�δ�����\u{5bd}ڲ��ó��� 1520���\u{5bd}ڣ�����Ҫ�ӽ��\u{735}��\u{5bd}������ڴ�������ƣ��ɲ��ý�ȡ��������ѭ������\n               �ӿڵķ�ʽ���мӽ��ܣ��ӽ��\u{73d}�������\u{735}��κ�Ӱ�졣\n   @code\n       //see slm_encrypt\n   @endcode\n   @see        slm_encrypt slm_login"]
    pub fn slm_decrypt(
        slm_handle: SLM_HANDLE_INDEX,
        inbuffer: *mut SS_BYTE,
        outbuffer: *mut SS_BYTE,
        len: SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ������ɵ��û���������С\n   @param[in]  slm_handle ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  type       �û����������\u{363}����Ͷ���� LIC_USER_DATA_TYPE\n   @param[out] pmem_size  �����û���������С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @see        LIC_USER_DATA_TYPE slm_user_data_getsize slm_user_data_read slm_user_data_write"]
    pub fn slm_user_data_getsize(
        slm_handle: SLM_HANDLE_INDEX,
        type_: LIC_USER_DATA_TYPE,
        pmem_size: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���������ݣ����Զ�ȡ #PUB #RAW �� #ROM\n   @param[in]  slm_handle   ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  type         �û����������\u{363}��ο� #LIC_USER_DATA_TYPE\n   @param[out] readbuf      �û���������ȡ������\n   @param[in]  offset       ��ȡ���û�������������ƫ��\n   @param[in]  len          �ⲿʹ�õĴ洢��������С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    �����������\u{5a7}�� 64k ���ݵĶ�ȡ��\n   @code\n       {\n           SS_UINT32 size = 0;\n           SS_BYTE   *buff = 0;\n           SS_UINT32 status = SS_OK;\n\n           status = slm_user_data_getsize(slm_handle, ROM, &size);   // ��ȡ\u{5bb}��������\n           if (status == SS_OK && size > 0)\n           {\n               buff = (SS_BYTE *)calloc(sizeof(SS_BYTE), size);\n               status = slm_user_data_read(slm_handle, ROM, buff, 0, size);\n               if(status != SS_OK)\n               {\n                   // todo: deal error code\n               }\n               // ���ڴ˴�����ȡ����\u{5bb}��������\n               free(buff);\n               buff = 0;\n           }\n       }\n   @endcode\n   @see        LIC_USER_DATA_TYPE slm_user_data_getsize slm_user_data_read slm_user_data_write"]
    pub fn slm_user_data_read(
        slm_handle: SLM_HANDLE_INDEX,
        type_: LIC_USER_DATA_TYPE,
        readbuf: *mut SS_BYTE,
        offset: SS_UINT32,
        len: SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      д���ɵĶ�д������ ,����������\u{5ae}ǰ����ȷ�����ڶ�д���Ĵ�С������ʹ�� #slm_user_data_getsize ���\n   @param[in]  slm_handle      ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  writebuf        Ҫд����������ݴ���\n   @param[in]  offset          ����������������ƫ�ƣ���������������д��λ��\n   @param[in]  len             Ҫд�����ݵĳ��ȣ�������\u{f3936}� = min(#slm_user_data_getsize, #SLM_MAX_WRITE_SIZE)\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ����д������\u{368}��Ӧ�ó���д�����ݣ���˴˽ӿڲ���Ҫ�������������\u{363}��ӿڻ�\u{5b1}�ӽ�����д���д����\n               ������д��ʱ��������ݳ��ȴ��� #SLM_MAX_WRITE_SIZE ����Ҫ���������н��з\u{5b0}�д�롣\n   @code\n       {\n           SS_UINT32 size = 0;\n           SS_BYTE   write[20] = { \"write data\" };\n           SS_UINT32 status = SS_OK;\n           SS_UINT32 offset = 0\n\n           status = slm_user_data_getsize(slm_handle, RAW, &size);   // ����д����д������\n           if (status == SS_OK && size > 0)\n           {\n               size = min( offset + sizeof(write), size);    // д�����ݲ��ó�����ȡ�������ݳ���\n               status = slm_user_data_write(slm_handle, write, offset, size);\n               if(status != SS_OK)\n               {\n                   // todo: deal error code\n               }\n           }\n       }\n   @endcode\n   @see       LIC_USER_DATA_TYPE   slm_user_data_getsize slm_user_data_read slm_user_data_write"]
    pub fn slm_user_data_write(
        slm_handle: SLM_HANDLE_INDEX,
        writebuf: *mut SS_BYTE,
        offset: SS_UINT32,
        len: SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���\u{5b8}�����ɵĹ�������������С����Ҫ��¼ 0������\n   @param[in]  slm_handle    0�����ɾ��\u{5b5}���������ɾ���\u{7b7}�\u{368}���˷�ʽ�õ���������С���� #slm_login �õ�\n   @param[in]  license_id    Ҫ��ȡ��������С�� ����ID\n   @param[out] pmem_size     ������������С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ĳЩ����£��û�ϣ���ڲ���¼���ɵ�����£���ȡ�����ɵĹ��������ݣ����������Ѿ������ã����ɵ��ڡ������þ��ȣ���\n               ��ʱ�û�����\u{368}�����ô˽ӿڽ��л�ȡ��ǰ������Ҫ��¼ 0�����ɣ�Ȼ�� 0������ �����Ҫ��ѯ�������� ����ID �����������ȡ�����ɵĹ��������ݡ�\n               ��ע���й� 0������ �Ľ��ܣ��ɲο���Virbox ������ϵ�����ɹ������ĵ��й��� 0������ ������\n   @see        slm_user_data_read_pub"]
    pub fn slm_pub_data_getsize(
        slm_handle: SLM_HANDLE_INDEX,
        license_id: SS_UINT32,
        pmem_size: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��ȡ���ɹ���������Ҫ��¼ 0������\n   @param[in]  slm_handle   0������ ���\u{5b5}���������ɾ���\u{7b7}�\u{368}���˷�ʽ�õ����������ݣ��� #slm_login �õ�\n   @param[in]  license_id   Ҫ��ȡ���������ݵ� ����ID\n   @param[out] readbuf      �ⲿ�洢Ҫ��ȡ���������ݵĻ�����\n   @param[in]  offset       Ҫ��ȡ������������ƫ��\n   @param[in]  len          �ⲿ�洢��������С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ĳЩ����£��û�ϣ���ڲ���¼���ɵ�����£���ȡ�����ɵĹ��������ݣ����������Ѿ������ã����ɵ��ڡ������þ��ȣ���\n               ��ʱ�û�����\u{368}�����ô˽ӿڽ��л�ȡ��ǰ������Ҫ��¼ 0�����ɣ�Ȼ�� 0������ �����Ҫ��ѯ�������� ����ID �����������ȡ�����ɵĹ��������ݡ�\n               ��ע���й� 0������ �Ľ��ܣ��ɲο���Virbox ������ϵ�����ɹ������ĵ��й��� 0������ ������\n   @code\n       {\n           SS_UINT32 size = 0;\n           SS_BYTE   *buff = 0;\n           SS_UINT32 status = SS_OK;\n           SS_UINT32 license_id = 1;   // ��Ҫ��ȡ������������ID\n\n           // �˴���Ҫ��¼������ɣ���ο� slm_login �� code ʾ��\n\n           status = slm_pub_data_getsize(slm_handle, license_id, &size);   // ��ȡ\u{5b8}�����ɵĹ���������\n           if (status == SS_OK && size > 0)\n           {\n               buff = (SS_BYTE *)calloc(sizeof(SS_BYTE), size);\n               status = slm_user_data_read(slm_handle, license_id, buff, 0, size);\n               if(status != SS_OK)\n               {\n                   // todo: deal error code\n               }\n               // ���ڴ˴�����ȡ��������\n               free(buff);\n               buff = 0;\n           }\n       }\n   @endcode\n   @see        slm_user_data_pub_getsize"]
    pub fn slm_pub_data_read(
        slm_handle: SLM_HANDLE_INDEX,
        license_id: SS_UINT32,
        readbuf: *mut SS_BYTE,
        offset: SS_UINT32,
        len: SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��ȡ�ѵ�¼���ɵ�״\u{32c}��Ϣ������������Ϣ��Ӳ������Ϣ��\n   @param[in]  slm_handle  ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  type        ��Ϣ���\u{363}��ο� #INFO_TYPE\n   @param[in]  format      ��Ϣ��ʽ���ο� #INFO_FORMAT_TYPE ����ǰ��\u{5a7}�� #JSON �� #STRUCT\n   @param[out] result      ���ؽ��������������سɹ�����Ҫ���� #slm_free �ͷ�\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    \u{368}�����ô˽ӿڣ����Ի�ȡ��ǰ��¼���ɵģ�������Ϣ���Ự��Ϣ��Ӳ������Ϣ����\u{5a7}��Ӳ�������������ļ��б�����\u{5a7}��Ӳ������\n   @code\n   // JSON ����˵����\n   - type = LICENSE_INFO ������\u{5b6}β����ڣ����ʾû�и��������ƣ�\n       {\n           \"rom_size\" :number(������\u{5a7}�\u{5a3}�\n           \"raw_size\" :number��������\u{5a7}�\u{5a3}�\n           \"pub_size\" :number��������\u{5a7}�\u{5a3}�\n\n           \"type\": \"local\"/\"remote\"/\"cloud\"\n           \"sn\":\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n           \"guid\":\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n           \"developer_id\":   \"xxxxxxxxxxxxxxxx\"\n           \"license_id\":     number\n           \"enable\":         bool\n           \"start_time\":     number\n           \"end_time\":       number\n           \"first_use_time\": number\n           \"span_time\":      number\n           \"counter\":        number\n           \"concurrent_type\": \"process\" / \"win_user_session\"    // ��������\n           \"concurrent\":     number    //������\n           \"version\":        number\n           \"module\":number\n           \"last_update_timestamp\":  number\n           \"last_update_timesn\":     number\n           \"lock_time\":      number     // ���ɱ�������ʱ�䣬�������ɲ������\u{5b6}�\n       }\n\n   - type = SESSION_INFO\n       {\n           \"app_process_id\":  number,\n           \"app_time_out\":    number,\n           \"session_id\":      ��\u{5bb}\u{5a7}��������\n           \"bios\": \"BIOS information\", ��������\u{5a7}�\u{5a3}�\n           \"cpuinfo\": \"CPU name\", ��������\u{5a7}�\u{5a3}�\n           \"sn\": \"\"(HEX16 String), ��\u{5bb}\u{5a7}��Ӳ������\n           \"user_guid\": \"\"(HEX16 String) ��\u{5bb}\u{5a7}��������\n           \"mac\":\"00-00-00-00-00-00\" ��������\u{5a7}�\u{5a3}�\n       }\n\n   - type = LOCK_INFO ��������\u{5a7}�\u{5a3}�\n       {\n           \"avaliable_space\": number(Bytes),\n           \"communication_protocol\": number,\n           \"lock_firmware_version\": \"0.0.0.0\",\n           \"lm_firmware_version\": \"1.1.1.1\",\n           \"h5_device_type\": number,\n           \"hardware_version\": \"2.2.2.2\",\n           \"manufacture_date\": \"2000-01-01 00:00:00\",\n           \"lock_sn\": \"\"(HEX16 String),\n           \"slave_addr\": number,\n           \"clock\": number(UTC Time),\n           \"user_info\": \"\"(HEX16 String)(128�\u{5bd}�)\n           \"inner_info\": \"\"(HEX16 String)(128�\u{5bd}ڣ�\n       }\n\n   - type = FILE_LIST\n       [\n        {\n           \"validate\":0,       (��־��Щ����Ч�����ع���)\n           \"type\":0,           (�ļ����\u{361}��������ļ�=0����\u{5b4}���ļ�(evx)=1����Կ�ļ�=2)\n           \"privilege\":0,      (�ļ�����Ȩ�ޣ����Ȩ��Ϊ 0xFF)\n           \"size\":123,         (�ļ���С����λ���\u{5bd}�)\n           \"time\":12345678,    (�ļ�����ʱ�䣬UTCʱ����)\n           \"name\":\"file1.evx\"  (�ļ�����)\n        },\n        {...}\n       ]\n\n   // STRUCT ����˵��\n   - type = LICENSE_INFO\n      result �ο��ṹ ST_SLM_LICENSE_INFO\n   - type = SESSION_INFO\n       result �ο��ṹ ST_SESSION_INFO\n   - type = LOCK_INFO\n       result �ο��ṹ ST_LOCK_INFO\n   - type = FILE_LIST\n       result �ο��ṹ ST_FILE_INFO_LIST\n   @endcode\n   @see INFO_TYPE INFO_FORMAT_TYPE SLM_HANDLE_INDEX slm_login"]
    pub fn slm_get_info(
        slm_handle: SLM_HANDLE_INDEX,
        type_: INFO_TYPE,
        format: INFO_FORMAT_TYPE,
        result: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      �������Զ����㷨�����ڿ�\u{5b4}���㷨�����ھ�\u{32c}����\u{5b4}�У���\u{5a7}��Ӳ��������\n               �ɿ����ߵ��� \\link D2CAPI \\endlink ���е� #d2c_add_pkg ǩ����\u{5b4}�д���ӿ����ɣ���ǰ����\u{5b4}���㷨���ص�����\n   @param[in]  slm_handle  ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  exfname     ���ڿ�\u{5b4}���㷨���ļ���\n   @param[in]  inbuf       Ҫ�������ڿ�\u{5b4}���㷨�����ݣ����뻺����\n   @param[in]  insize      �������ݳ���(���\u{5a7}�\u{5bb}�������С�ο��꣺ #SLM_MAX_INPUT_SIZE )\n   @param[out] poutbuf     ���ڿ�\u{5b4}���㷨�ķ������ݣ����������\n   @param[in]  outsize     ������泤��\n   @param[out] pretsize    ʵ�ʷ��ػ��泤��(���\u{5a7}�\u{5bb}�������С�ο��꣺ #SLM_MAX_OUTPUT_SIZE )\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ���������\u{33f}��Դ� APP ��������\u{5b2}�ؼ����뵽���ڣ�������\u{338}���ͳ ����4 �� ����5 û��\u{32b}������𡣣���\u{5b2}�������������ھ���ϵ�е��Ͽͻ����������������\u{33f}��\u{530}���������ҵ������\u{7fc}����㷨��\u{5b2}������������\u{5b4}�У���\n               ����������Ҫ�����ɰ\u{f6a21}�\n\n               ���ɰ\u{f6a35}ĺô���\n               -# �ͻ�����Ҫ�Լ�д�������ж���Ȩ�����\n               -# ��\u{5b2}�Ĵ�����Խ������������Ȩ��\u{378}����ʹ����ʱ���\u{7b4}�ʧЧ���������䷽�㡣\n               -# ������ʧЧ\u{5ae}�\u{e3b38}��㷨����\u{5b4}�У������������\u{336}��������жϣ��ǳ���ȫ��\n\n   @code\n       {\n           SS_BYTE inbuff[MAX_BUFFER_SIZE] = { 0 };\n           SS_BYTE outbuff[MAX_BUFFER_SIZE] = { 0 };\n           char    *dongle_exe = \"dongle.evx\"          // ���ڿ�\u{5b4}�г����ļ���\n           SS_UINT32 retlen = 0;\n           SS_UINT32 status = 0;\n\n           memcpy(inbuff, \"1234567890\", 10);\n\n           status = slm_execute_static(slm_handle, dongle_exe, inbuff, 10, outbuff, MAX_BUFFER_SIZE, &retlen);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n           // todo: �������ڳ���ķ�������\n       }\n   @endcode\n   @see        slm_login slm_execute_dynamic slm_snippet_execute"]
    pub fn slm_execute_static(
        slm_handle: SLM_HANDLE_INDEX,
        exfname: *const ::std::os::raw::c_char,
        inbuf: *mut SS_BYTE,
        insize: SS_UINT32,
        poutbuf: *mut SS_BYTE,
        outsize: SS_UINT32,
        pretsize: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      �������Զ����㷨�����ڿ�\u{5b4}���㷨�����ڶ�\u{32c}\u{5b4}�д��루��\u{5a7}��Ӳ����������Ӧ�ó������й��������ص����ڽ���\u{5b4}��\n   @param[in]  slm_handle  ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  exf_buffer  ��\u{32c}exf �㷨���������ɿ����ߵ��� \\link D2CAPI \\endlink ���е� #gen_dynamic_code �ӿ����ɵ� D2C����\n   @param[in]  exf_size    ��\u{32c}exf �ļ���С\n   @param[in]  inbuf       Ҫ�������ڿ�\u{5b4}���㷨�����ݣ����뻺����\n   @param[in]  insize      �������ݳ���(���\u{5a7}�\u{5bb}�������С�ο��꣺ #SLM_MAX_INPUT_SIZE )\n   @param[out] poutbuf     ���ڿ�\u{5b4}���㷨�ķ������ݣ����������\n   @param[in]  outsize     ������泤��\n   @param[out] pretsize    ʵ�ʷ��ػ��泤��(���\u{5a7}�\u{5bb}�������С�ο��꣺ #SLM_MAX_OUTPUT_SIZE )\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ������ #slm_execute_static ���ھ�\u{32c}����\u{5b4}�С����ھ�\u{32c}����\u{5b4}�У����ڳ�ʼ��Ӳ����ʱ��\u{368}��ǩ���ļ�����\u{5b4}�д������ص����ڣ��������ñ��������ڡ�\n               �� #slm_execute_dynamic ���ڶ�\u{32c}����\u{5b4}�У�����ǰ\u{368}�� \\link D2CAPI \\endlink ǩ�ÿ�\u{5b4}�д��������Ӧ�ó���һ�𣬵���Ҫ\u{5b4}��ʱ���ص����ڣ�\u{5b4}����ɺ����ڻ�ɾ���˳��\u{a3b32}������ڳ�ʱ�䱣����\n   @code\n       {\n           SS_BYTE     exf_buff[MAX_BUFFER_SIZE] = { 0 };       // ��\u{32c}����������������\n           SS_UINT32   exf_size = 0;                            // ��\u{32c}������������С\n           SS_BYTE     inbuff[MAX_BUFFER_SIZE] = { 0 };\n           SS_BYTE     outbuff[MAX_BUFFER_SIZE] = { 0 };\n           SS_UINT32   retlen = 0;\n           SS_UINT32   status = 0;\n\n           // 1������\u{32c}���뻺������\u{5b5}��\n           // {...}\n\n           memcpy(inbuff, \"1234567890\", 10);\n\n           status = slm_execute_static(slm_handle, exf_buff, exf_size, inbuff, 10, outbuff, MAX_BUFFER_SIZE, &retlen);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n           // todo: �������ڳ���ķ�������\n       }\n   @endcode\n   @see        slm_login slm_execute_static slm_snippet_execute"]
    pub fn slm_execute_dynamic(
        slm_handle: SLM_HANDLE_INDEX,
        exf_buffer: *mut SS_BYTE,
        exf_size: SS_UINT32,
        inbuf: *mut SS_BYTE,
        insize: SS_UINT32,
        poutbuf: *mut SS_BYTE,
        outsize: SS_UINT32,
        pretsize: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      Virbox���ɷ��� �ڴ��й��ڴ�����\n   @param[in]  slm_handle   ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  size         �����ڴ��С����� #SLM_MEM_MAX_SIZE ��\n   @param[out] mem_id       �����й��ڴ�id\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    Virbox���ɷ��� ���й��ڴ�ԭ���� APP ������Ч��������Ϊƾ\u{5a4}���� Virbox���ɷ��� ģ�������ݼ���������У�飬���ڴ����������û�����ģ�\n               �����\u{7b7}��Ƿ��\u{7b8}�,�ڿͼ��Ѳ鿴��۸�ʹ�á�\n\n               �û����\u{530}��Լ� APP ��һЩ�������ݱ��浽 Virbox���ɷ��� ���й��ڴ棬�����ʺſ��\u{e8ec}���ݿ���ʺ������룬�漰������Ȩ�\u{7b5}���ʱ���ݷŵ� Virbox���ɷ��� �ڴ��й����档\n               ����һ���� APP �� Virbox���ɷ��� ��϶ȼ������ߣ���\u{5b9}�ڿ����� Virbox���ɷ��� ���������С�\n\n               �ڴ��й\u{735}ĺô���\n               -# ���������ڴ治й�ܡ��\u{7b7}��۸ġ�\n               -# ���Կ��\u{7f3}\u{330}�ȫ�������ݡ�\n               -# APP���������ɡ�Virbox���ɷ��� ����ǿ��ϣ�������\u{5b9}���ƽ��������ߡ����ڿ���Ҫ�\u{5b9}�������ؽ�����ʹ��������\n\n               ˵�����й��ڴ�ÿ�����������ڴ�Ϊ #SLM_MEM_MAX_SIZE ��ÿ���ڴ�\u{368}��һ�� mem_id ��ʶ����������ڴ��\u{734}�СΪ 256kb��\n\n   @code\n       {\n           SS_UINT32 status = SS_OK;\n           SS_UINT32 mem_index = 0;\n           SS_UINT32 mem_size = 1024;\n           SS_BYTE   data[] = \"test data....\";\n           SS_BYTE   read[100] = { 0 };\n           SS_UINT32 write_len = 0;\n           SS_UINT32 read_len = 0;\n\n           status = slm_mem_alloc(slm_handle, mem_size, &mem_index);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n           status = slm_mem_write(slm_handle, mem_index, 0, strlen((char *)data), data, &write_len);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n           status = slm_mem_read(slm_handle, mem_index, 0, write_len, read, &read_len);\n           if(status != SS_OK)\n           {\n               //todo do: deal error code\n               return ;\n           }\n           //�Ա�ԭʼ���ݺͶ�ȡ���������Ƿ����\n           //if(data == read)\n           //{\n           //    SUCCESS;\n           //}\n           //else\n           //{\n           //    FAILURE;\n           //}\n\n           status = slm_mem_free(slm_handle, mem_index);\n       }\n   @endcode\n   @see        slm_mem_free slm_mem_read slm_mem_write"]
    pub fn slm_mem_alloc(
        slm_handle: SLM_HANDLE_INDEX,
        size: SS_UINT32,
        mem_id: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief     �ͷ��й��ڴ�\n   @param[in] slm_handle    ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in] mem_id        �й��ڴ�id\n   @return    �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks\n   @code\n       //see slm_mem_alloc\n   @endcode\n   @see       slm_mem_alloc slm_mem_free slm_mem_read slm_mem_write"]
    pub fn slm_mem_free(slm_handle: SLM_HANDLE_INDEX, mem_id: SS_UINT32) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      Virbox���ɷ��� �ڴ��й\u{736}�\n   @param[in]  slm_handle    ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  mem_id        �й��ڴ�id\n   @param[in]  offset        ��ȡ�й�����ƫ��\n   @param[in]  len           ��ȡ�й����ݳ���\n   @param[out] readbuff      �ⲿ�洢�й����ݻ���\n   @param[out] readlen       ����ʵ�ʶ�ȡ����\n   @return    �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks\n   @code\n       //see slm_mem_alloc\n   @endcode\n   @see slm_mem_alloc slm_mem_free slm_mem_write"]
    pub fn slm_mem_read(
        slm_handle: SLM_HANDLE_INDEX,
        mem_id: SS_UINT32,
        offset: SS_UINT32,
        len: SS_UINT32,
        readbuff: *mut SS_BYTE,
        readlen: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      Virbox���ɷ��� �ڴ��й��ڴ�д��\n   @param[in]  slm_handle    ���ɾ��\u{5b5}���� #slm_login �õ�\n   @param[in]  mem_id        �й��ڴ�id\n   @param[in]  offset        �й�����ƫ��\n   @param[in]  len           д����й����ݳ���\n   @param[in]  writebuff     ��Ҫд���й��ڴ���������ݻ���\n   @param[out] numberofbyteswritten ����ʵ��д�ĳ���\n   @return     �ɹ����� SS_OK��ʧ���\u{b7d7b}���Ӧ�Ĵ�����\n   @remarks\n   @code\n       //see slm_mem_alloc\n   @endcode\n   @see slm_mem_alloc slm_mem_free slm_mem_read"]
    pub fn slm_mem_write(
        slm_handle: SLM_HANDLE_INDEX,
        mem_id: SS_UINT32,
        offset: SS_UINT32,
        len: SS_UINT32,
        writebuff: *mut SS_BYTE,
        numberofbyteswritten: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ����Ƿ����ڵ���\n   @param[in]  auth     ��\u{5a4}����(������������ NULL ���ɣ�\n   @return     SS_UINT32 ������, ���� SS_OK ����δ����\n   @remarks     ������� #slm_init \u{5ae}��ſ�ʹ�ã������п��\u{73b}���ɳ������\n   @see        slm_init"]
    pub fn slm_is_debug(auth: *mut ::std::os::raw::c_void) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      \u{368}��\u{5a4}�����\u{363}���ȡ�ѵ�¼���ɵ��豸\u{5a4}��\n   @param[in]  slm_handle  ���ɾ������ #slm_login �õ�\n   @param[in]  cert_type   \u{5a4}�����\u{363}��ο� #CERT_TYPE\n   @param[out] cert        \u{5a4}�黺����\n   @param[in]  cert_size   ��������С\n   @param[out] cert_len    ���ص��豸\u{5a4}���С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ��ȡ�豸\u{5a4}�飬�˴����豸\u{5b8}Ӳ������������\n               ��� cert_type = #CERT_TYPE_DEVICE_CERT���书���� #slm_get_device_cert ��ȫһ�£�\n               ���Ϊ�������\u{363}����\u{5a7}��Ӳ������\n               \u{368}���˽ӿڿ��Ի�ȡ�������ĸ�\u{5a4}�顢�豸��CA ���豸������ϳ��豸\u{5a4}������\n   @see    slm_login slm_get_device_cert"]
    pub fn slm_get_cert(
        slm_handle: SLM_HANDLE_INDEX,
        cert_type: CERT_TYPE,
        cert: *mut SS_BYTE,
        cert_size: SS_UINT32,
        cert_len: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��ȡ�ѵ�¼�ļ�����\u{5a4}��\n   @param[in]  slm_handle  ���ɾ������ #slm_login �õ�\n   @param[out] device_cert �豸\u{5a4}�黺����\n   @param[in]  buff_size   ��������С\n   @param[out] return_size ���ص��豸\u{5a4}���С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ��ȡ�ѵ�¼�ļ�����\u{5a4}�飬�˴��ļ�����\u{5b8}Ӳ����������������\n   @see        slm_login"]
    pub fn slm_get_device_cert(
        slm_handle: SLM_HANDLE_INDEX,
        device_cert: *mut SS_BYTE,
        buff_size: SS_UINT32,
        return_size: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      �豸������\u{5a4}����\u{5a7}��Ӳ������\n   @param[in]  slm_handle          ���ɾ������ #slm_login �õ�\n   @param[in]  verify_data         ��\u{5a4}���ݣ��������\u{5b7}�\"SENSELOCK\"(9�\u{5bd}�)��ͷ��\n   @param[in]  verify_data_size    ��\u{5a4}���ݴ�С����С����Ϊ #SLM_VERIFY_DATA_SIZE (41)���\u{5bd}�\n   @param[out] signature           ���ص�ǩ�����\n   @param[in]  signature_buf_size  ��������С\n   @param[out] signature_size      ǩ�������С\n   @return     �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks    ����ʹ���豸˽Կǩ������Ҫ��Ӳ����\u{5a4}�鹫Կ��ǩ\n   @code\n       {\n           SS_UINT32       status = SS_OK;\n           SS_BYTE         verify_data[41] = {0};\n           SS_BYTE         my_data[32] = {\"verify data...\"};\n           const SS_BYTE   header[9] = {\"SENSELOCK\"};\n           SS_BYTE         signature[2048] = {0};\n           SS_UINT32       signature_size = 0;\n\n           memcpy(verify_data, header, sizeof(header));\n           memcpy(verify_data + sizeof(header), my_data, sizeof(my_data));\n\n           status = slm_sign_by_device(slm_handle, verify_data, sizeof(verify_data), signature, sizeof(signature), &signature_size);\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n           }\n       }\n   @endcode\n   @see        slm_login"]
    pub fn slm_sign_by_device(
        slm_handle: SLM_HANDLE_INDEX,
        verify_data: *mut SS_BYTE,
        verify_data_size: SS_UINT32,
        signature: *mut SS_BYTE,
        signature_buf_size: SS_UINT32,
        signature_size: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief         ��ȡʱ���\u{7b8}����ݣ���������ʱ��У\u{5fc}����\n   @param[in]     slm_handle  ���ɾ������ #slm_login �õ�\n   @param[out]    rand        �����\n   @param[out]    lock_time   ��ʱ��\n   @param[in,out] pc_time     PCʱ�䣬���ص�PCʱ�䣨����0��ȡ��ʱʱ�䣩\n   @return        �ɹ����� SS_OK ��ʧ���\u{b7d7b}���Ӧ������"]
    pub fn slm_adjust_time_request(
        slm_handle: SLM_HANDLE_INDEX,
        rand: *mut SS_BYTE,
        lock_time: *mut SS_UINT32,
        pc_time: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��˸\u{5b8}ʾ��\n   @param[in]  slm_handle      ���ɾ������ #slm_login �õ�\n   @param[in]  led_ctrl        ���ƿ��ƽṹ( #ST_LED_CONTROL )\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @remarks\n   @code\n       {\n           ST_LED_CONTROL led = { 0 };\n           SS_UINT32 status = SS_OK;\n\n           led.index = 0;         //  0��ʾ��ɫLED��1��ʾ��ɫLED\n           led.state = 2;         //  0�����رգ�1�����\u{bfaa3}� 2������˸\n           led.interval = 1000;   //  ��˸��������룩\n\n           status = slm_led_control(slm_handle, &led);\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n           }\n       }\n   @endcode\n   @see        slm_login ST_LED_CONTROL"]
    pub fn slm_led_control(
        slm_handle: SLM_HANDLE_INDEX,
        led_ctrl: *mut ST_LED_CONTROL,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��� Runtime �� �� Virbox���ɷ��� �İ汾��Ϣ.\n   @param[out] api_version  API�İ汾�����ǳɹ���\n   @param[out] ss_version   Virbox���ɷ��� �İ汾\n   @return     �ɹ����� SS_OK ��ʧ���\u{b7d7b}���Ӧ�Ĵ�����"]
    pub fn slm_get_version(api_version: *mut SS_UINT32, ss_version: *mut SS_UINT32) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief     �ͷ�API�ڷ��������\n   @param[in] buffer API ���ɵĶ�"]
    pub fn slm_free(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "   @brief      ����Ӳ�������ɣ�D2C�� �� @link D2CAPI @endlink �� VirboxLM ���������� ����\n   @param[in]  d2c_pkg     d2c�ļ�����\n   @param[out] error_msg   ������Ϣ����Ҫ���� #slm_free �ͷ�\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}��ش�����\n   @remarks:   D2C���ڿ��\u{730}����������ݣ���˷��صĴ�������ϢҲ�� json ����ṹ����Ҫ�\u{5b1}������\n               ˵������ǰ�ӿڽ�\u{5a7}��Ӳ������������������Ҫ���������ɣ������ #slm_update_ex �ӿ�\n   @code\n     [\n       {\"pkg_order\":1, \"pkg_desc\":\"package decription.\", \"status\": 0},\n       {\"pkg_order\":2, \"pkg_desc\":\"package decription.\", \"status\": 0}\n     ]\n   @endcode"]
    pub fn slm_update(
        d2c_pkg: *mut ::std::os::raw::c_char,
        error_msg: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      �����ɿ������� VirboxLM ���������� ǩ����Ӳ��������������\n   @param[in]  lock_sn     Ӳ�������������ţ�Ψһ���к�,ʮ�������\u{5b7}�����ʽ������ѡ\n   @param[in]  d2c_pkg     d2c�ļ����ݣ�����\n   @param[out] error_msg   ������Ϣ����ʹ����Ҫ���� #slm_free �ͷ�\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}��ش�����\n   @remarks:\n           - �˽ӿ�\u{5a7}��Ӳ�����������������ݵ�����\n           - ��������ΪӲ��������ʱ������\u{5b8}�� lock_sn���������Ч�ʣ�Ҳ�ɲ���д����������Ϊ������ʱ��lock_sn ��\u{5b5}����������\n           - ��������ΪӲ��������ʱ��D2C���ڿ��\u{730}����������ݣ�ÿ���������Ĵ�����Ϣ���� json �ṹ��ʽ\u{368}�� error_msg ���أ���Ҫ�\u{5b1}����\n           - ��������Ϊ��������ʱ�������뽫\u{5b1}���Է���\u{5b5}��ʽ���أ�error_msg ����������\n   @code\n     error_msg �ṹ��\n     [\n       {\"pkg_order\":1, \"pkg_desc\":\"package decription.\", \"status\": 0},\n       {\"pkg_order\":2, \"pkg_desc\":\"package decription.\", \"status\": 0}\n     ]\n   @endcode\n   @see    slm_update"]
    pub fn slm_update_ex(
        lock_sn: *mut SS_BYTE,
        d2c_pkg: *mut ::std::os::raw::c_char,
        error_msg: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ���ڶ�����������\u{5b8}��������Ψһ���кţ������ڿ�\u{5b4}���㷨��ϣ���\u{5a7}��Ӳ������\n   @param[in]  lock_sn     ���ţ�Ψһ���к�,ʮ�������\u{5b7}�����\n   @param[in]  inside_file ���ڶ����ļ���\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}��ش�����\n   @remarks    Virbox �ṩ��\u{368}�����뼤�\u{ee66}����Ӳ����������һ�� Virbox���ɣ��ù�����Ҫ\u{368}����\u{5b4}���㷨����ϣ��\u{b5975}Ĳ�������Ϊ��\n               ��һ��������������\u{5a7}�\u{5b6}��뼤���ʹ���ļ� slac_enable.evd���ļ��������⣬��С��ò����� 256�\u{5bd}ڣ�\n               �ڶ�������д���ڿ�\u{5b4}���㷨��������˼�ṩ�� h5ses.lib �� h5ses_lm.lib �⣬ʵ�\u{5b6}���ת���Ĺ��\u{323}�\n               ��������\u{368}��\u{5b4}�����ڿ�\u{5b4}���㷨�������� #slm_execute_static �� ������������ݣ���ʹ���ڿ�\u{5b4}���㷨�����ڽ�����ת��Ϊ\n                       Ӳ������ʶ����м��ļ����ļ����������趨����\n               ���Ĳ���\u{368}������ #slm_d2c_update_inside �ӿڣ����������ɵ��м��ļ�ת��Ϊ��ʽ�� Virbox���ɡ�\n\n               �ر�˵�������뼤�\u{edfd}��ʹ�ý�Ϊ���ӣ���Ҫд���ڴ���ļ���Ҫ������������Ҫʹ�ô˹��ܣ�����ϵ��˼�����������\u{5a7}�\u{5a1}�\n   @code\n       {\n           SS_UINT32 status = SS_OK;\n           SS_BYTE   data_buf[1024] = { 0 };\n           SS_UINT32 data_size = 0;\n           char *sn = \"9733c80100070205106100030015000c\";\n\n           memcpy(data_buf, \"1234567890\", 10);\n\n           status = slm_execute_static(slm_handle, \"test.evx\", NULL, 0, data_buf, 10, &data_size);\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n           }\n\n           status = slm_d2c_update_inside(sn, \"test.evd\");\n           if(status != SS_OK)\n           {\n               // todo: deal error code\n           }\n       }\n   @endcode\n   @see    slm_execute_static"]
    pub fn slm_d2c_update_inside(
        lock_sn: *mut ::std::os::raw::c_char,
        inside_file: *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ö�ٱ�������Ϣ\n   @param[out]  device_info    �豸������Ϣ������ʹ��ʱ������� #slm_free �ͷ�\n   @return      �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks     �˽ӿڿ���ö�ٵ����������豸��Ϣ���˴����豸��Ϣ���ݿɲο� #slm_get_info #LOCK_INFO �еĽṹ����\n   @code\n       // �ο� slm_get_license_info ��ʾ������\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_enum_device(device_info: *mut *mut ::std::os::raw::c_char) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ö�ٱ�������Ϣ��\u{5a7}�\u{5b0}�����\u{5b5}���ͻ�ȡ\n   @param[in]   format         ��Ϣ��ʽ���ο� #INFO_FORMAT_TYPE ����ǰ��\u{5a7}�� #JSON �� #STRUCT\n   @param[out]  device_info    �豸������Ϣ������ʹ��ʱ������� #slm_free �ͷ�\n   @return      �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks     �˽ӿڿ���ö�ٵ����������豸��Ϣ���˴����豸��Ϣ���ݿɲο� #slm_get_info #LOCK_INFO �еĽṹ����\n   @code\n       // format = JSON\n           device_info ���ݺ� slm_enum_device ��������һ�£� �ο� slm_get_license_info ��ʾ������\n       // format = STRUCT\ndevice_info ���ݲο� ST_DEV_INFO_LIST���ο� slm_get_license_info_ex ʾ������\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_enum_device_ex(
        format: INFO_FORMAT_TYPE,
        device_info: *mut *mut ::std::os::raw::c_void,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ö��\u{5b8}���豸����������ID\n   @param[in]   device_info   \u{5b8}��ĳ������½\n   @param[out]  license_ids   �����������ɵ�ID���飬#JSON ��ʽ����Ҫ���� #slm_free �ͷ� license_ids\n   @return      �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks     �� #slm_enum_device ��ȡ����ǰ�豸��Ϣ��\u{368}���豸��Ϣ��ȡ������Ϣ����Ҫʵ�\u{5b2}��õ�¼���ɣ���ɲ鿴�������ݵĹ���\n   @code\n       // �ο� slm_get_license_info ʾ������\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_enum_license_id(
        device_info: *const ::std::os::raw::c_char,
        license_ids: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ö��\u{5b8}���豸����������ID��\u{5a7}�\u{5b0}�����\u{5b5}���ͻ�ȡ\n   @param[in]   device_info    \u{5b8}��ĳ������Ϣ\n   @param[in]   format         ��Ϣ��ʽ���ο� #INFO_FORMAT_TYPE ����ǰ��\u{5a7}�� #JSON �� #STRUCT\n   @param[out]  license_ids    �����������ɵ�ID���飬JSON��ʽ����Ҫ���� #slm_free �ͷ� license_ids\n   @return      �ɹ�����SS_OK��ʧ�\u{737}�����Ӧ������\n   @remarks     �� #slm_enum_device ��ȡ����ǰ�豸��Ϣ��\u{368}���豸��Ϣ��ȡ������Ϣ����Ҫʵ�\u{5b2}��õ�¼���ɣ���ɲ鿴�������ݵĹ���\n   @code\n       //  �ο� slm_get_license_info_ex ʾ������\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_enum_license_id_ex(
        device_info: *mut ST_DEV_INFO,
        format: INFO_FORMAT_TYPE,
        license_ids: *mut *mut ::std::os::raw::c_void,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ��ȡ\u{5b8}���豸��\u{5b8}�����ɵ�ȫ����Ϣ\n   @param[in]   device_info    \u{5b8}��ĳ������½\n   @param[in]   license_id     \u{5b8}������ID\n   @param[out]  license_info   �������ɵ���Ϣ #JSON ��ʽ ��\u{36c}�� #slm_get_info �� #LICENSE_INFO\n   @return      �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks     ��ȡ��\u{5b8}���豸�� ����ID �б�������ͳ��������������\n   @code\n       {\n           char        *lic_id = NULL;\n           char        *dev_desc = NULL;\n           char        *lic_info = NULL;\n           SS_UINT32   status = SS_OK;\n           Json::Reader reader;      // �˴�ѡ��jsoncpp����json����\n           Json::Value  root;\n           Json::Value  lic;\n\n           status = slm_enum_device(&dev_desc);    // ����Ҫ�ȱ��������豸\n           if ( status == SS_OK && dev_desc != NULL && reader.parse(dev_desc, root))\n           {\n               for (int i = 0; i < root.size(); i++)\n               {\n                   status = slm_enum_license_id(root[i].toStyledString().c_str(), &lic_id);    // ��λ�ȡÿ���豸������ID\n                   if (status == SS_OK && lic_id != NULL)\n                   {\n                       printf(lic_id);\n                       printf(\"\\n\");\n\n                       if (reader.parse(lic_id, lic))\n                       {\n                           for (int j = 0; j < lic.size(); j++)\n                           {\n                               status = slm_get_license_info(root[i].toStyledString().c_str(), lic[j].asInt(), &lic_info);  // ����ȡ���ɵ���ϸ��Ϣ\n                               if (lic_info)\n                               {\n                                   printf(lic_info);\n                                   printf(\"\\n\");\n                                   slm_free(lic_info);\n                                   lic_info = NULL;\n                               }\n                           }\n                       }\n                       slm_free(lic_id);\n                       lic_id = NULL;\n                   }\n               }\n               slm_free(dev_desc);\n               dev_desc = NULL;\n           }\n       }\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_get_license_info(
        device_info: *const ::std::os::raw::c_char,
        license_id: SS_UINT32,
        license_info: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief       ��ȡ\u{5b8}���豸��\u{5b8}�����ɵ�ȫ����Ϣ��\u{5a7}�\u{5b0}�����\u{5b5}���ͻ�ȡ\n   @param[in]   device_info    \u{5b8}��ĳ������½\n   @param[in]   format         ��Ϣ��ʽ���ο� #INFO_FORMAT_TYPE ����ǰ��\u{5a7}�� #JSON �� #STRUCT\n   @param[in]   license_id     \u{5b8}������ID\n   @param[out]  license_info   �������ɵ���Ϣ #JSON ��ʽ ��\u{36c}�� #slm_get_info �� #LICENSE_INFO\n   @return      �ɹ����� SS_OK��ʧ�\u{737}�����Ӧ������\n   @remarks     ��ȡ��\u{5b8}���豸������ID�б�������ͳ��������������\n   @code\n       {\n           void        *dev_desc = NULL;\n           SS_UINT32   dev_count = 0;\n           void        *lic_desc = NULL;\n           void         *lic_info = NULL;\n           int         status = SS_OK;\n\n           status = slm_enum_device_ex(STRUCT, &dev_desc);\n\n           if (status == SS_OK && dev_desc != NULL)\n           {\n               ST_DEV_INFO_LIST *dl = (ST_DEV_INFO_LIST*)dev_desc;\n               //printf(\"DEV LIST COUNT:%d\\n\", dl->count);\n               for (int i = 0; i != dl->count; ++i)\n               {\n                   status = slm_enum_license_id_ex(&dl->info[i].dev_info, STRUCT, &lic_desc);\n                   if (status == SS_OK && lic_desc != NULL)\n                   {\n                       ST_LICENSE_IDS  *lic = (ST_LICENSE_IDS*)lic_desc;\n                       //printf(\"License Count : %d\\n\", lic->count);\n                       for (int j = 0; j != lic->count; ++j)\n                       {\n                           status = slm_get_license_info_ex(&dl->info[i].dev_info, lic->lic_ids[j], STRUCT, &lic_info);\n                           if (status == SS_OK && lic_info != NULL)\n                           {\n                               //printf(\"LicenseID = %d; first use time = %d\\n\", ((ST_SLM_LICENSE_INFO*)lic_info)->lic_id, ((ST_SLM_LICENSE_INFO*)lic_info)->first_use_time);\n                               slm_free(lic_info);\n                               lic_info = NULL;\n                           }\n                       }\n                       slm_free(lic_desc);\n                       lic_desc = NULL;\n                   }\n               }\n               slm_free(dev_desc);\n               dev_desc = NULL;\n           }\n       }\n   @endcode\n   @see slm_enum_device slm_enum_license_id slm_get_license_info"]
    pub fn slm_get_license_info_ex(
        device_info: *mut ST_DEV_INFO,
        license_id: SS_UINT32,
        format: INFO_FORMAT_TYPE,
        license_info: *mut *mut ::std::os::raw::c_void,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief     ���ģ��\n   @param[in] slm_handle     ���ɾ������ #slm_login �õ�\n   @param[in] module_id      ģ��ID����Χ�ɣ�1 ~ 64��\n   @return    ģ����ڷ��� SS_OK �������ڷ��� SS_ERROR_LICENSE_MODULE_NOT_EXISTS , ���\u{b7d7b}�����������"]
    pub fn slm_check_module(slm_handle: SLM_HANDLE_INDEX, module_id: SS_UINT32) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��Ƭ����\u{5b4}�У������\u{7f2}��ع��ģ�\n   @param[in]  slm_handle      ���ɾ��\n   @param[in]  snippet_code    ��Ƭ����\n   @param[in]  code_size       ��Ƭ�����С\n   @param[in]  input           ��������\n   @param[in]  input_size      �������ݳ���\n   @param[out] output          ���������\n   @param[in]  outbuf_size     �������������\n   @param[out] output_size     ������ݳ���\n   @return     �ɹ�����SS_OK��ʧ�\u{737}�����Ӧ�Ĵ�����\n   @see        slm_login slm_execute_static slm_execute_dynamic"]
    pub fn slm_snippet_execute(
        slm_handle: SLM_HANDLE_INDEX,
        snippet_code: *mut SS_BYTE,
        code_size: SS_UINT32,
        input: *mut SS_BYTE,
        input_size: SS_UINT32,
        output: *mut SS_BYTE,
        outbuf_size: SS_UINT32,
        output_size: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��ȡ Runtime ���Ӧ�Ŀ�����ID\n   @param[out] developer_id          ���������ID������������\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks    ��� developer_id �Ļ�����С�� #SLM_DEVELOPER_ID_SIZE �����Ʊػ������ջ�����"]
    pub fn slm_get_developer_id(developer_id: *mut SS_BYTE) -> SS_UINT32;
}
extern "C" {
    #[doc = "  @brief      ʹ���ѵ�¼�������ɽ���ǩ������\u{5a7}��������\n  @param[in]  slm_handle       ���ɾ������ #slm_login �õ�\n  @param[in]  sign_data        Ҫǩ�������ݣ�����16�\u{5bd}ڣ����64�\u{5bd}ڣ�\n  @param[in]  sign_length      Ҫǩ�������ݳ���\n  @param[out] signature        ǩ�����������\n  @param[in]  max_buf_size     ǩ�������������С\n  @param[out] signature_length ǩ�����ʵ�ʳ���\n  @return     �ɹ����� SS_OK ��ʧ�\u{737}��ش�����\n  @remarks    ��\u{36c}�����ߡ���\u{36c}���ɵ�ǩ������ǲ�һ���ġ�\n  @see        slm_license_verify"]
    pub fn slm_license_sign(
        slm_handle: SLM_HANDLE_INDEX,
        sign_data: *mut SS_BYTE,
        sign_length: SS_UINT32,
        signature: *mut SS_BYTE,
        max_buf_size: SS_UINT32,
        signature_length: *mut SS_UINT32,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "  @brief      ��������ǩ��������ݽ�����ǩ����\u{5a7}��������\n  @param[in]  sign_data        Ҫǩ�������ݣ����� 16�\u{5bd}ڣ���� 64�\u{5bd}ڣ�\n  @param[in]  sign_length      Ҫǩ�������ݳ���\n  @param[in]  signature        ǩ���������\n  @param[in]  signature_length ǩ���������\n  @param[out] sign_info        ǩ��������Ϣ��json�ṹ������ʹ��ʱ����Ҫ���� #slm_free �ͷ�\n  @return     ��ǩ�ɹ����� SS_OK ��ʧ�\u{737}��ش�����\n  @remarks   -����ɹ�����Ҫ���� #slm_free �ͷ� sign_info\n             -��ǩ���\u{33f}��Բ���¼����\n  @code\n//json����\n{\n\"type\":2,                                   // 2��ʾ����\n\"developer_id\":0000000000000000,            // ������ID\n\"license_id\":0,                             // ����ID\n\"guid\":xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,    // �û�guid�������;�����\n\"sn\":00000000000000000000000000000000,      // ���ţ������;�����\n\"rand\":0,                                   // �����\n}\n@endcode\n  @see  slm_license_sign slm_free"]
    pub fn slm_license_verify(
        sign_data: *mut SS_BYTE,
        sign_length: SS_UINT32,
        signature: *mut SS_BYTE,
        signature_length: SS_UINT32,
        sign_info: *mut *mut ::std::os::raw::c_char,
    ) -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      \u{368}���������ô�����Ϣ\n   @param[in]  error_code  \u{368}���� API ����ʧ�\u{73a}\u{f7d7b}صĴ�����\u{5b5}\n   @param[in]  language_id Ҫ�����\u{5b7}��������ԣ��� #LANGUAGE_CHINESE_ASCII ��\n   @return     �ɹ����ش������ı�������Ϣ������Ҫ���� #slm_free �ͷţ���ʧ�\u{737}��ؿ�\u{5b8}�� NULL\n   @remarks    �ر�ע�⣺�������ı�������Ϣ������Ҫ���� #slm_free �ͷ�"]
    pub fn slm_error_format(error_code: SS_UINT32, language_id: SS_UINT32) -> *const SS_CHAR;
}
extern "C" {
    #[doc = "   @brief      ����ʼ���������� #slm_init ��Ӧ\n   @see        slm_init\n   @remarks    #slm_cleanup �Ƿ��\u{7f3}\u{330}�ȫ�ģ��˺��������鿪���ߵ��ã���Ϊ�����˳�ʱϵͳ���Զ�����û���ͷŵ��ڴ棬\n               �������ߵ��ã�Ϊ�˱�\u{5a4}���\u{7f3}\u{335}��� Runtime API �İ�ȫ�ԣ��˺��������ڳ����˳�ʱ���á�\n               һ�������˴˺�������������API���� #slm_init ��������ʹ�á�"]
    pub fn slm_cleanup() -> SS_UINT32;
}
extern "C" {
    #[doc = "   @brief      ��չ���ýӿ�\n   @param[in]  config    ���ò����� #JSON ��\n               1. #slm_login ��չ������\u{5b8}�����ɵ�¼���������������\u{5b7}��ע������\u{5b7} URL ���Ȳ��ó��� #SLM_MAX_CLOUD_SERVER_LENGTH �궨�峤�ȡ�\n                           {\"urls\": {\"cloud_runtime_url\": \"http://rt.senseyun.com\",\"slock_url\": \"http://sl.senseyun.com\",\"dl_url\": \"http://ll.senseyun.com\"}}\n   @return     �ɹ����� SS_OK ��ʧ�\u{737}�����Ӧ������\n   @remarks    ��\u{5a7}�\u{5b6}��\u{7f3}\u{335}��ã����\u{7f3}\u{330}�ȫ���뱣\u{5a4}��������ع�������\u{5ae}ǰ\u{5b4}�С�"]
    pub fn slm_extensions_config(config: *const ::std::os::raw::c_char) -> SS_UINT32;
}
